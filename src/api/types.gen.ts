// This file is auto-generated by @hey-api/openapi-ts

export type AWSEventBridgeIntegration = {
    attributes: {
        /**
         * The AWS account ID, 12 digits.
         */
        'aws-account-id': string;
        /**
         * Message from service that points to nature of a problem
         */
        readonly 'err-message'?: string | null;
        /**
         * The name of the partner event source.
         */
        readonly 'event-source'?: string;
        /**
         * The ARN of the partner event source.
         */
        readonly 'event-source-arn'?: string;
        /**
         * Connection name
         */
        name: string;
        /**
         * The AWS region name.
         */
        region: string;
        /**
         * Status of integration.
         */
        status?: 'active' | 'disabled' | 'failed' | 'pending';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account this integration belongs to.
         */
        readonly account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
    };
    type: 'aws-event-bridge-integrations';
};

/**
 * Status of integration.
 */
export type status = 'active' | 'disabled' | 'failed' | 'pending';

/**
 * Status of integration.
 */
export const status = {
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FAILED: 'failed',
    PENDING: 'pending',
} as const;

export type type = 'accounts';

export const type = {
    ACCOUNTS: 'accounts',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AWSEventBridgeIntegrationDocument = {
    data?: AWSEventBridgeIntegration;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AWSEventBridgeIntegrationListingDocument = {
    data?: Array<AWSEventBridgeIntegration>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Grants the permissions declared in a role to a user, team, or service account.
 *
 * An access policy is applied to an environment or a specific workspace.
 */
export type AccessPolicy = {
    attributes?: {
        /**
         * The access policy is a built-in read-only policy that cannot be updated or deleted.
         */
        readonly 'is-system'?: boolean;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships: {
        /**
         * Grant access to the account and to all environments and workspaces in the account.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * Grant access to the environment and all workspaces within it.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The roles with permissions.
         */
        roles: {
            data: Array<{
                id: string;
                type: 'roles';
            }>;
        };
        /**
         * Role binding to a service account.
         */
        'service-account'?: {
            data: {
                id: string;
                type: 'service-accounts';
            } | null;
        };
        /**
         * Role binding to a team.
         */
        team?: {
            data: {
                id: string;
                type: 'teams';
            } | null;
        };
        /**
         * Role binding to a user.
         */
        user?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * Grant access to the workspace.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'access-policies';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccessPolicyDocument = {
    data?: AccessPolicy;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccessPolicyListingDocument = {
    data?: Array<AccessPolicy>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Access Token for the Scalr API.
 */
export type AccessToken = {
    attributes?: {
        /**
         * Date/Time the token was created.
         */
        readonly 'created-at'?: string;
        /**
         * The description of the token.
         */
        description?: string | null;
        /**
         * Date/Time when the token was last used.
         */
        readonly 'last-used-at'?: string | null;
        /**
         * The JWT token which an API client should pass in the `Authorization: Bearer <token>`
         * header. Available only in the [Create an Access Token](#create-an-access-token) response.
         */
        readonly token?: string | null;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The user who created the token.
         */
        readonly 'created-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
    };
    type: 'access-tokens';
};

export type type2 = 'users';

export const type2 = {
    USERS: 'users',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccessTokenDocument = {
    data?: AccessToken;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccessTokenListingDocument = {
    data?: Array<AccessToken>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * API Resource for the account.
 */
export type Account = {
    attributes: {
        /**
         * The list of allowed IP networks for IP fencing
         */
        'allowed-ips'?: Array<string>;
        readonly 'created-at'?: string;
        /**
         * @deprecated
         */
        readonly 'last-login-attempt-at'?: string | null;
        /**
         * @deprecated
         */
        readonly 'login-attempts'?: number | null;
        /**
         * The name of the account
         */
        name: string;
        /**
         * The list of account's quotas
         */
        quotas?: {
            /**
             * The maximal number of agents
             */
            agents?: number;
            /**
             * Indicates if the before-after hooks are available for an account
             */
            'before-after-hooks-available'?: boolean;
            /**
             * Indicates if the cost estimation is available for an account
             */
            'cost-estimate-available'?: boolean;
            /**
             * The maximal number of environments
             */
            environments?: number;
            /**
             * The maximal number of concurrent runs
             */
            'max-concurrent-runs'?: number;
            /**
             * Indicates if the policy group checks are available for an account
             */
            'policy-group-checks-available'?: boolean;
            /**
             * The maximal number of policy groups
             */
            'policy-groups'?: number;
            /**
             * The maximal number of registry modules
             */
            'registry-modules'?: number;
            /**
             * The maximal number of registry templates
             */
            'registry-templates'?: number;
            /**
             * The maximal number of run triggers
             */
            'run-triggers'?: number;
            /**
             * Indicates if the service accounts are available for an account
             */
            'service-accounts-available'?: boolean;
            /**
             * Indicates if the SSO is available for an account
             */
            'sso-available'?: boolean;
            /**
             * The maximal number of users
             */
            users?: number;
            /**
             * The maximal number of VCS providers
             */
            'vcs-providers'?: number;
            /**
             * The maximal number of workspaces
             */
            workspaces?: number;
        };
        /**
         * If enabled, Scalr support staff will be able to access the account for troubleshooting purposes.
         */
        'support-access-enabled'?: boolean;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The billing plan of this account
         */
        readonly 'billing-plan'?: {
            data: {
                id: string;
                type: 'billing-plans';
            } | null;
        };
        /**
         * The identity provider of this account
         */
        'identity-provider'?: {
            data: {
                id: string;
                type: 'identity-providers';
            } | null;
        };
        /**
         * The user that owns this account
         */
        owner: {
            data: {
                id: string;
                type: 'users';
            };
        };
    };
    type: 'accounts';
};

export type type3 = 'billing-plans';

export const type3 = {
    BILLING_PLANS: 'billing-plans',
} as const;

/**
 * API resource describing the external blob storage setting, where
 * Scalr will store this account blobs: e.g. source code, terraform state, and logs.
 */
export type AccountBlobSettings = {
    attributes?: {
        /**
         * The value of the aud claim for the identity token.
         */
        'aws-s3-audience'?: string | null;
        /**
         * AWS S3 Storage bucket name. Bucket must already exist.
         */
        'aws-s3-bucket-name'?: string | null;
        /**
         * AWS S3 bucket region.
         */
        'aws-s3-region'?: string;
        /**
         * Amazon Resource Name (ARN) of the IAM Role to assume.
         */
        'aws-s3-role-arn'?: string | null;
        /**
         * Type of backend
         */
        'backend-type'?: 'google' | 'aws-s3';
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        /**
         * This field contains the last error description, when these settings doesn't work properly.
         */
        readonly 'error-message'?: string | null;
        /**
         * Service Account JSON key.
         * Required IAM roles: `Storage Admin` assigned on a `google-storage-bucket` bucket.
         * See: [use IAM with bucket](https://cloud.google.com/storage/docs/access-control/using-iam-permissions#bucket-iam).
         */
        'google-credentials'?: {
            [key: string]: unknown;
        } | null;
        /**
         * Optional [customer supplied encryption key](https://cloud.google.com/storage/docs/encryption/customer-supplied-keys).
         * Must be exactly 32 bytes, encoded into base64:
         * ```sh
         * $ openssl rand 32 | base64
         * NfsPPHBVNlU8ZLBU9BeBIoL29rqtduyQAEw3vxf6kaY=
         * ```
         */
        'google-encryption-key'?: string | null;
        /**
         * Google Cloud project ID.
         */
        'google-project'?: string | null;
        /**
         * Google Storage bucket name. Bucket must already exist.
         */
        'google-storage-bucket'?: string | null;
        /**
         * The resource last update timestamp.
         */
        readonly 'updated-at'?: string | null;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    type: 'account-blob-settings';
};

/**
 * Type of backend
 */
export type backend_type = 'google' | 'aws-s3';

/**
 * Type of backend
 */
export const backend_type = {
    GOOGLE: 'google',
    AWS_S3: 'aws-s3',
} as const;

export type type4 = 'account-blob-settings';

export const type4 = {
    ACCOUNT_BLOB_SETTINGS: 'account-blob-settings',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccountBlobSettingsDocument = {
    data?: AccountBlobSettings;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccountDocument = {
    data?: Account;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccountListingDocument = {
    data?: Array<Account>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents account metrics.
 */
export type AccountMetrics = {
    'billings-flex-runs-count'?: number;
    'billings-flex-runs-minutes-count'?: number;
    'billings-run-minutes-count'?: number;
    'billings-runs-count'?: number;
    'environments-count': number;
    'quota-max-concurrency'?: number;
    'runs-awaiting-confirmation': number;
    'runs-concurrency': number;
    'runs-count': number;
    'runs-failed': number;
    'runs-queue-size'?: number;
    'runs-successful': number;
    'workspaces-count': number;
};

/**
 * Represents an account-user relation.
 */
export type AccountUser = {
    attributes?: {
        /**
         * The relation status. Can be: `Active`, `Inactive`, `Pending`.
         */
        status?: 'Active' | 'Inactive' | 'Pending';
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        teams?: {
            data: Array<{
                id: string;
                type: 'teams';
            }> | null;
        };
        user?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
    };
    type: 'account-users';
};

/**
 * The relation status. Can be: `Active`, `Inactive`, `Pending`.
 */
export type status2 = 'Active' | 'Inactive' | 'Pending';

/**
 * The relation status. Can be: `Active`, `Inactive`, `Pending`.
 */
export const status2 = {
    ACTIVE: 'Active',
    INACTIVE: 'Inactive',
    PENDING: 'Pending',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccountUserDocument = {
    data?: AccountUser;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AccountUserListingDocument = {
    data?: Array<AccountUser>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * An agent represents a single instance of self-hosted runner installed on a customer's on-prem
 * infrastructure.
 *
 * An agent resource is automatically created when [self-hosted runner](../../agent_pools.html)
 * connects to the API server to join it [agent pool](agent-pools.html). In order to connect to the
 * pool, the runner requires an [agent pool token](access-tokens.html#create-an-agent-pool-access-token).
 */
export type Agent = {
    attributes: {
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        /**
         * Contains the error message if the agent is in an `errored` status.
         */
        readonly 'error-message'?: string | null;
        /**
         * The timestamp when the agent was last seen online.
         */
        readonly 'last-seen-at'?: string;
        /**
         * The name of the agent. This must be unique within the agent pool.
         */
        name: string;
        /**
         * The agent's OS distribution name and version (ex: `centos_8`, `ubuntu_20`)
         */
        os: string;
        /**
         * The agent's current status
         *
         * * `busy` - The agent is working on a task.
         * * `errored` - The agent has an error and can't operate correctly.
         * The attribute `error-message` has the details.
         * * `idle` - The agent is idle and ready to start working on a task.
         * * `offline` - API server hasn't seen the agent's heartbeat for 30 seconds.
         */
        readonly status?: 'idle' | 'busy' | 'offline' | 'errored';
        /**
         * The agent's version.
         */
        readonly version?: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The agent pool this agent is a member of.
         */
        readonly pool?: {
            data: {
                id: string;
                type: 'agent-pools';
            } | null;
        };
    };
    type: 'agents';
};

/**
 * The agent's current status
 *
 * * `busy` - The agent is working on a task.
 * * `errored` - The agent has an error and can't operate correctly.
 * The attribute `error-message` has the details.
 * * `idle` - The agent is idle and ready to start working on a task.
 * * `offline` - API server hasn't seen the agent's heartbeat for 30 seconds.
 */
export type status3 = 'idle' | 'busy' | 'offline' | 'errored';

/**
 * The agent's current status
 *
 * * `busy` - The agent is working on a task.
 * * `errored` - The agent has an error and can't operate correctly.
 * The attribute `error-message` has the details.
 * * `idle` - The agent is idle and ready to start working on a task.
 * * `offline` - API server hasn't seen the agent's heartbeat for 30 seconds.
 */
export const status3 = {
    IDLE: 'idle',
    BUSY: 'busy',
    OFFLINE: 'offline',
    ERRORED: 'errored',
} as const;

export type type5 = 'agent-pools';

export const type5 = {
    AGENT_POOLS: 'agent-pools',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AgentDocument = {
    data?: Agent;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AgentListingDocument = {
    data?: Array<Agent>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * With the agent pool resource you can manage a pool of [self-hosted agents](../../agent_pools.html)
 *
 * A workspace may be configured to use an agent pool to execute terraform [runs](runs.html).
 * Agents could be hosted on a physical or virtual machines within the customer's network.
 */
export type AgentPool = {
    attributes: {
        /**
         * Indicates whether the pool is used by any workspace.
         */
        readonly 'in-use'?: boolean;
        /**
         * The name of the agent pool. This must be unique within a Scalr scope
         * (e.g. account or environment).
         */
        name: string;
        /**
         * Indicates whether the VCS support is enabled for agents in the pool.
         */
        'vcs-enabled'?: boolean;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account the agent pool belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * The list of agents connected to the pool.
         */
        readonly agents?: {
            data: Array<{
                id: string;
                type: 'agents';
            }> | null;
        };
        /**
         * The environment the agent pool belongs to. This relationship is deprecated.
         * @deprecated
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The list of workspaces attached to the pool. Can be used to bulk link/unlink workspaces.
         */
        workspaces?: {
            data: Array<{
                id: string;
                type: 'workspaces';
            }> | null;
        };
    };
    type: 'agent-pools';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AgentPoolDocument = {
    data?: AgentPool;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type AgentPoolListingDocument = {
    data?: Array<AgentPool>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Applies are the details of a request to apply a Terraform plan.
 *
 * An apply may or may not be successful as indicated by the `status` attribute.
 */
export type Apply = {
    attributes?: {
        /**
         * Apply execution details.
         */
        'execution-details'?: {
            [key: string]: string;
        };
        /**
         * The number of resources added.
         */
        'resource-additions'?: number | null;
        /**
         * The number of resources updated.
         */
        'resource-changes'?: number | null;
        /**
         * The number of resources destroyed.
         */
        'resource-destructions'?: number | null;
        /**
         * The Apply's current status.
         *
         * Transient states:
         * * `pending` - Apply has been created but not yet `queued`.
         * * `queued` - Queued and waiting for capacity/and or quota to be available.
         * * `running` - Running.
         *
         * Final states:
         * * `canceled` - Apply canceled in some way.
         * * `errored` - An error occurred during the apply. See `output` for details.
         * * `finished` - Apply completed successfully.
         * * `unreachable` - Apply will not be run.
         */
        status?: 'pending' | 'queued' | 'running' | 'finished' | 'canceled' | 'errored' | 'unreachable';
        /**
         * Date/Time of transition to each status that has occurred.
         */
        'status-timestamps'?: {
            [key: string]: string;
        };
    };
    readonly id?: string;
    readonly links?: {
        /**
         * URL to download the apply output.
         */
        output?: string | null;
        self?: string;
    };
    type: 'applies';
};

/**
 * The Apply's current status.
 *
 * Transient states:
 * * `pending` - Apply has been created but not yet `queued`.
 * * `queued` - Queued and waiting for capacity/and or quota to be available.
 * * `running` - Running.
 *
 * Final states:
 * * `canceled` - Apply canceled in some way.
 * * `errored` - An error occurred during the apply. See `output` for details.
 * * `finished` - Apply completed successfully.
 * * `unreachable` - Apply will not be run.
 */
export type status4 = 'pending' | 'queued' | 'running' | 'finished' | 'canceled' | 'errored' | 'unreachable';

/**
 * The Apply's current status.
 *
 * Transient states:
 * * `pending` - Apply has been created but not yet `queued`.
 * * `queued` - Queued and waiting for capacity/and or quota to be available.
 * * `running` - Running.
 *
 * Final states:
 * * `canceled` - Apply canceled in some way.
 * * `errored` - An error occurred during the apply. See `output` for details.
 * * `finished` - Apply completed successfully.
 * * `unreachable` - Apply will not be run.
 */
export const status4 = {
    PENDING: 'pending',
    QUEUED: 'queued',
    RUNNING: 'running',
    FINISHED: 'finished',
    CANCELED: 'canceled',
    ERRORED: 'errored',
    UNREACHABLE: 'unreachable',
} as const;

export type type6 = 'applies';

export const type6 = {
    APPLIES: 'applies',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ApplyDocument = {
    data?: Apply;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type BillingPlan = {
    attributes?: {
        amount?: number;
        'included-runs'?: number | null;
        'included-runs-minutes'?: number | null;
        'plan-type'?: 'monthly' | 'yearly' | 'deprecated-yearly';
        prices?: Array<{
            amount?: number | null;
            currency: string;
            interval: string;
            type: 'membership' | 'pre-paid-runs' | 'flex-runs' | 'flex-runs-minutes';
            'unit-label'?: string | null;
        }>;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        tier?: {
            data: {
                id: string;
                type: 'billing-tiers';
            } | null;
        };
    };
    type: 'billing-plans';
};

export type plan_type = 'monthly' | 'yearly' | 'deprecated-yearly';

export const plan_type = {
    MONTHLY: 'monthly',
    YEARLY: 'yearly',
    DEPRECATED_YEARLY: 'deprecated-yearly',
} as const;

export type type7 = 'billing-tiers';

export const type7 = {
    BILLING_TIERS: 'billing-tiers',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type BillingPlanDocument = {
    data?: BillingPlan;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type BuiltInProviderTypes = 'aws' | 'azurerm' | 'google' | 'scalr';

export const BuiltInProviderTypes = {
    AWS: 'aws',
    AZURERM: 'azurerm',
    GOOGLE: 'google',
    SCALR: 'scalr',
} as const;

/**
 * An optional explanation for why run action was done.
 */
export type Comment = {
    /**
     * The reason.
     */
    comment?: string;
};

/**
 * A Configuration Version describes the version of a Terraform configuration files.
 *
 * Each run is associated with a configuration version. It provides details of the source of the configuration files,
 * the upload status, and the relationships to VCS and the workspace.
 */
export type ConfigurationVersion = {
    attributes?: {
        /**
         * Indicates if a run should automatically be queued when the configuration has been uploaded.
         */
        'auto-queue-runs'?: boolean;
        /**
         * Date/Time the configuration version was created.
         */
        readonly 'created-at'?: string;
        /**
         * This field contains the error description, when this configuration version's
         * status is `errored`.
         */
        readonly 'error-message'?: string | null;
        /**
         * The input variables definitions.
         *
         * Example:
         * ```js
         * [
         * {
         * "description": "The name of the CloudSQL database.",
         * "name": "cloudsql_database",
         * "type": "string"
         * },
         * {"...": ""..."}
         * ]
         * ```
         */
        readonly inputs?: Array<RegistryInputOptional | RegistryInputRequired>;
        /**
         * Indicates the configuration version can only be used to perform dry runs that comprise the plan,
         * cost estimation (if enabled) and policy checks.
         *
         * With this set to `true` the configuration cannot be used for an apply and never requires confirmation.
         */
        'is-dry'?: boolean;
        /**
         * A blob size in bytes.
         */
        readonly size?: number | null;
        /**
         * The origin for the configuration version.
         */
        readonly source?: string;
        /**
         * The Configuration version's current status.
         *
         * * `pending` - waiting for the configuration files to upload.
         * * `uploaded` - upload successful. At this point if the `auto-queue-runs: true` the new run should be `queued`.
         * * `errored` - uploaded files post processing failed. Attribute `error-message` contains the details.
         */
        readonly status?: 'errored' | 'pending' | 'uploaded';
        /**
         * Date/Time of transition to each status that has occurred.
         */
        readonly 'status-timestamps'?: {
            [key: string]: string;
        };
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
        /**
         * URL for terraform configuration templates upload, that could be used to `PUT` a tar.gz archive of a local workspace directory. Available only in the create `configuration-versions` response.
         */
        readonly upload?: string | null;
    };
    relationships?: {
        /**
         * When configuration version was uploaded from a VCS, this relation points to the Git commit information
         */
        readonly 'vcs-revision'?: {
            data: {
                id: string;
                type: 'vcs-revisions';
            } | null;
        };
        /**
         * The workspace the configuration version belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'configuration-versions';
};

/**
 * The Configuration version's current status.
 *
 * * `pending` - waiting for the configuration files to upload.
 * * `uploaded` - upload successful. At this point if the `auto-queue-runs: true` the new run should be `queued`.
 * * `errored` - uploaded files post processing failed. Attribute `error-message` contains the details.
 */
export type status5 = 'errored' | 'pending' | 'uploaded';

/**
 * The Configuration version's current status.
 *
 * * `pending` - waiting for the configuration files to upload.
 * * `uploaded` - upload successful. At this point if the `auto-queue-runs: true` the new run should be `queued`.
 * * `errored` - uploaded files post processing failed. Attribute `error-message` contains the details.
 */
export const status5 = {
    ERRORED: 'errored',
    PENDING: 'pending',
    UPLOADED: 'uploaded',
} as const;

export type type8 = 'vcs-revisions';

export const type8 = {
    VCS_REVISIONS: 'vcs-revisions',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ConfigurationVersionDocument = {
    data?: ConfigurationVersion;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ConfigurationVersionListingDocument = {
    data?: Array<ConfigurationVersion>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A request to confirm a run. Includes optional time when apply should be queued.
 */
export type ConfirmRequest = {
    /**
     * The UTC datetime at which the Apply should be queued.
     */
    'apply-at'?: string | null;
    /**
     * The reason.
     */
    comment?: string;
};

/**
 * A Cost Estimate is the details of the cost estimation phase of a `run` in Scalr.
 *
 * Cost estimation is optional and is enabled/disable per `environment`. If enabled a cost estimation
 * is performed immediately after Terraform plan has completed for every run in every workspace,
 * including dry runs.
 */
export type CostEstimate = {
    attributes?: {
        /**
         * The change in the estimated cost ($) from the previous run (if any).
         */
        'delta-monthly-cost'?: string;
        /**
         * When the cost estimate status is `errored`, this field contains the error description.
         */
        'error-message'?: string | null;
        /**
         * The number of resources in the terraform plan, that were included into the estimation.
         *
         * Cost estimation in Scalr supports a number of terraform resources from major
         * [cloud providers](https://docs.scalr.io/docs/cost-estimation)
         */
        'matched-resources-count'?: number | null;
        /**
         * The estimated current monthly cost ($).
         */
        'prior-monthly-cost'?: string;
        /**
         * The estimated monthly cost ($) if the plan is applied.
         */
        'proposed-monthly-cost'?: string;
        /**
         * The total number of resources in the terraform plan.
         */
        'resources-count'?: number | null;
        /**
         * The Cost estimate's current status.
         *
         * Transient states:
         * * `pending` - Cost estimation has been created but not yet `queued`.
         * * `queued` - Queued and waiting for capacity to be available.
         *
         * Final states:
         * * `canceled` - The cost estimate has been canceled.
         * * `errored` - The cost estimate has finished with an error. Attribute `error-message` contains the details.
         * * `finished` - The cost estimate has completed successfully.
         * * `unreachable` - The cost estimate will not run.
         */
        status?: 'pending' | 'queued' | 'finished' | 'canceled' | 'errored' | 'unreachable';
        /**
         * Date/Time of transition to each status that has occurred.
         */
        'status-timestamps'?: {
            [key: string]: string;
        };
        /**
         * The number of resources in the terraform plan that were excluded from the estimation.
         */
        'unmatched-resources-count'?: number | null;
    };
    readonly id?: string;
    readonly links?: {
        /**
         * Link to download the cost breakdown [JSON formatted output](https://www.infracost.io/docs/multi_project/report/#examples).
         */
        breakdown?: string | null;
        /**
         * Link to download the raw output of the cost estimation.
         */
        output?: string | null;
        self?: string;
    };
    type: 'cost-estimates';
};

/**
 * The Cost estimate's current status.
 *
 * Transient states:
 * * `pending` - Cost estimation has been created but not yet `queued`.
 * * `queued` - Queued and waiting for capacity to be available.
 *
 * Final states:
 * * `canceled` - The cost estimate has been canceled.
 * * `errored` - The cost estimate has finished with an error. Attribute `error-message` contains the details.
 * * `finished` - The cost estimate has completed successfully.
 * * `unreachable` - The cost estimate will not run.
 */
export type status6 = 'pending' | 'queued' | 'finished' | 'canceled' | 'errored' | 'unreachable';

/**
 * The Cost estimate's current status.
 *
 * Transient states:
 * * `pending` - Cost estimation has been created but not yet `queued`.
 * * `queued` - Queued and waiting for capacity to be available.
 *
 * Final states:
 * * `canceled` - The cost estimate has been canceled.
 * * `errored` - The cost estimate has finished with an error. Attribute `error-message` contains the details.
 * * `finished` - The cost estimate has completed successfully.
 * * `unreachable` - The cost estimate will not run.
 */
export const status6 = {
    PENDING: 'pending',
    QUEUED: 'queued',
    FINISHED: 'finished',
    CANCELED: 'canceled',
    ERRORED: 'errored',
    UNREACHABLE: 'unreachable',
} as const;

export type type9 = 'cost-estimates';

export const type9 = {
    COST_ESTIMATES: 'cost-estimates',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type CostEstimateDocument = {
    data?: CostEstimate;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a request to create an [IAM](https://docs.scalr.io/docs/identity-and-access-management) user.
 */
export type CreateUser = {
    attributes: {
        /**
         * If set to `true`, the user will be asked to change the temporary password on the first sign in.
         */
        'change-password-on-sign-in'?: boolean;
        'created-at'?: string | null;
        email: string;
        'full-name'?: string | null;
        /**
         * Must be at least 8 characters long and contain at least one digit, one lowercase letter, one uppercase letter, and one special character.
         */
        password?: string;
        /**
         * User status. Can be: `Active`, `Inactive`, `Pending`. Pending user will be activated after the first sign in.
         */
        status?: 'Active' | 'Inactive' | 'Pending';
    };
    readonly id?: string;
    readonly links?: {
        self?: string;
    };
    relationships?: {
        'identity-providers'?: {
            data: Array<{
                id: string;
                type: 'identity-providers';
            }> | null;
        };
    };
    type: 'users';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type CreateUserDocument = {
    data?: CreateUser;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type DatadogIntegration = {
    attributes: {
        /**
         * The API key.
         */
        'api-key': string | null;
        /**
         * HTTP(s) URL.
         */
        'deployment-url'?: string | null;
        /**
         * Message from service that points to nature of a problem
         */
        readonly 'err-message'?: string | null;
        /**
         * Name of Datadog integration
         */
        name: string;
        /**
         * Status of integration.
         */
        status?: 'active' | 'disabled' | 'failed';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The account this integration belongs to.
         */
        account: {
            data: {
                id: string;
                type: 'accounts';
            };
        };
    };
    type: 'datadog-integrations';
};

/**
 * Status of integration.
 */
export type status7 = 'active' | 'disabled' | 'failed';

/**
 * Status of integration.
 */
export const status7 = {
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FAILED: 'failed',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type DatadogIntegrationDocument = {
    data?: DatadogIntegration;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type DatadogIntegrationListingDocument = {
    data?: Array<DatadogIntegration>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Environments are collections of related workspaces that correspond to functional areas, SDLC stages,
 * projects or any grouping that is required.
 *
 * An account can have multiple environments.
 *
 * Workspaces within an environment are where Terraform configurations are run to deploy infrastructure,
 * and where state files are stored.
 *
 * An Environment can have set of policy groups assigned that are applied to all workspaces in the environment.
 * The Environment can also have variables, credentials, registry modules, and VCS providers
 * that are available to every workspace.
 */
export type Environment = {
    attributes: {
        /**
         * Indicates if the cost estimation should be performed for `runs` in the environment.
         */
        'cost-estimation-enabled'?: boolean;
        /**
         * Date/Time the environment was created.
         */
        readonly 'created-at'?: string;
        readonly 'created-by-email'?: string | null;
        /**
         * The name of the environment.
         */
        name: string;
        readonly permissions?: {
            [key: string]: unknown;
        };
        readonly status?: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account that owns this environment.
         */
        readonly account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * The user that created the environment.
         */
        readonly 'created-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * Provider configurations used in the environment workspaces by default.
         */
        'default-provider-configurations'?: {
            data: Array<{
                id: string;
                type: 'provider-configurations';
            }> | null;
        };
        'policy-groups'?: {
            data: Array<{
                id: string;
                type: 'policy-groups';
            }> | null;
        };
        /**
         * Provider configurations available for this environment.
         */
        readonly 'provider-configurations'?: {
            data: Array<{
                id: string;
                type: 'provider-configurations';
            }> | null;
        };
        tags?: {
            data: Array<{
                id: string;
                type: 'tags';
            }> | null;
        };
    };
    type: 'environments';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type EnvironmentDocument = {
    data?: Environment;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type EnvironmentListingDocument = {
    data?: Array<Environment>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Error object.
 *
 * see: https://jsonapi.org/format/#errors
 */
export type Error = {
    code?: string | null;
    detail?: string | null;
    meta?: {
        [key: string]: unknown;
    } | null;
    source?: {
        pointer?: string;
    } | null;
    status?: string | null;
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ErrorDocument = {
    errors?: Array<Error>;
};

/**
 * Represents a Webhook Event Definition.
 *
 * Use [List Event Definitions](event-definitions.html#list-event-definitions) to obtain
 * the all Scalr events available for use in webhooks. Then pass a number of the event IDs
 * within `webhook.event` relationship in [Create Webook](webhooks.html#create-webhook) or
 * [Update Webhook](webhooks.html#update-webhook).
 */
export type EventDefinition = {
    attributes: {
        /**
         * The event details.
         */
        description?: string | null;
        /**
         * The name of the event.
         */
        name: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    type: 'event-definitions';
};

export type type10 = 'event-definitions';

export const type10 = {
    EVENT_DEFINITIONS: 'event-definitions',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type EventDefinitionDocument = {
    data?: EventDefinition;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type EventDefinitionListingDocument = {
    data?: Array<EventDefinition>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * The Identity Provider (IdP).
 */
export type IdentityProvider = {
    attributes?: {
        /**
         * The IdP type. Can be one of `scalr`, `ldap`, or `saml`.
         */
        'idp-type'?: 'scalr' | 'ldap' | 'saml';
        /**
         * The IdP name.
         */
        name?: string;
        /**
         * Represents the verification status with the external IdP (SAML/LDAP only)
         */
        'verification-status'?: 'pending' | 'success' | 'running';
    };
    readonly id?: string;
    readonly links?: {
        self?: string;
    };
    relationships?: {
        /**
         * The account this IdP belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
    };
    type: 'identity-providers';
};

/**
 * The IdP type. Can be one of `scalr`, `ldap`, or `saml`.
 */
export type idp_type = 'scalr' | 'ldap' | 'saml';

/**
 * The IdP type. Can be one of `scalr`, `ldap`, or `saml`.
 */
export const idp_type = {
    SCALR: 'scalr',
    LDAP: 'ldap',
    SAML: 'saml',
} as const;

/**
 * Represents the verification status with the external IdP (SAML/LDAP only)
 */
export type verification_status = 'pending' | 'success' | 'running';

/**
 * Represents the verification status with the external IdP (SAML/LDAP only)
 */
export const verification_status = {
    PENDING: 'pending',
    SUCCESS: 'success',
    RUNNING: 'running',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type IdentityProviderDocument = {
    data?: IdentityProvider;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A terraform module in the [Private Module Registry](../../module.html).
 */
export type Module = {
    attributes: {
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        /**
         * The description of the module.
         *
         * By default, this is taken from the VCS repository description. For mono repos you likely
         * want to override this behavior by passing this argument in a
         * [Create Module](modules.html#create-a-module) operation.
         */
        readonly description?: string;
        /**
         * This field contains the error description, when this module's status is `errored`.
         */
        readonly 'error-message'?: string | null;
        /**
         * The module name.
         */
        readonly name?: string;
        /**
         * A name of a system, this module was written for.
         *
         * For multi-cloud modules this argument should match terraform provider name (ex: `aws` or
         * `google`), in other cases the convention is to name it `system`
         */
        readonly provider?: string;
        /**
         * The `source` by which the module should be addressed from a HCL template.
         */
        readonly source?: string;
        /**
         * The Module's current status.
         *
         * Initial status:
         * * `pending` -  The initial status of a module once it has been created. Now Scalr will
         * download the code from the VCS, and create a `module-version` resource for each matching
         * Git tag.
         *
         * Ending statuses:
         * * `no_version_tags` - a Module has been created, however the Module source repository
         * has no tags.
         * * `setup_complete` - a Module has been created, and at least one ModuleVersion has been
         * successfully uploaded. Scalr assigns this status while some module-versions upload might
         * be still in-progress. If you want to ensure a specific version was uploaded, you can poll
         * [List Module Versions](module-versions.html#list-module-versions) for the `ok` status.
         * * `errored` - Module has been created, however its synchronization has failed. Attribute
         * `error-message` contains the details.
         */
        readonly status?: 'no_version_tags' | 'pending' | 'setup_complete' | 'errored';
        'vcs-repo': {
            /**
             * A reference to the module's VCS repository.
             *
             * For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`.
             * Azure DevOps Services has the format `<org>/<project>/<repo>`.
             */
            identifier: string;
            /**
             * The repository sub-directory where the module source is located.
             * If omitted or submitted as an empty string, this defaults to the repository's root.
             */
            path?: string;
            /**
             * Specify this attribute when a module's releases are namespaced within a repository's
             * Git tags. This is usually the case for a mono repos with individually versioned
             * components. For example if your module is tagged `my-module/v1.0.0` it's `tag_prefix`
             * is  `my-module/`.
             */
            'tag-prefix'?: string;
        };
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The account this module belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * The user who has created the module.
         */
        readonly 'created-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * The environment this module belongs to.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The module's latest version.
         */
        readonly 'latest-module-version'?: {
            data: {
                id: string;
                type: 'module-versions';
            } | null;
        };
        /**
         * The module's latest successful version.
         */
        readonly 'module-version'?: {
            data: {
                id: string;
                type: 'module-versions';
            } | null;
        };
        /**
         * The IDs of the module versions.
         */
        readonly 'module-versions'?: {
            data: Array<{
                id: string;
                type: 'module-versions';
            }> | null;
        };
        /**
         * The module's VCS provider.
         */
        'vcs-provider': {
            data: {
                id: string;
                type: 'vcs-providers';
            };
        };
    };
    type: 'modules';
};

/**
 * The Module's current status.
 *
 * Initial status:
 * * `pending` -  The initial status of a module once it has been created. Now Scalr will
 * download the code from the VCS, and create a `module-version` resource for each matching
 * Git tag.
 *
 * Ending statuses:
 * * `no_version_tags` - a Module has been created, however the Module source repository
 * has no tags.
 * * `setup_complete` - a Module has been created, and at least one ModuleVersion has been
 * successfully uploaded. Scalr assigns this status while some module-versions upload might
 * be still in-progress. If you want to ensure a specific version was uploaded, you can poll
 * [List Module Versions](module-versions.html#list-module-versions) for the `ok` status.
 * * `errored` - Module has been created, however its synchronization has failed. Attribute
 * `error-message` contains the details.
 */
export type status8 = 'no_version_tags' | 'pending' | 'setup_complete' | 'errored';

/**
 * The Module's current status.
 *
 * Initial status:
 * * `pending` -  The initial status of a module once it has been created. Now Scalr will
 * download the code from the VCS, and create a `module-version` resource for each matching
 * Git tag.
 *
 * Ending statuses:
 * * `no_version_tags` - a Module has been created, however the Module source repository
 * has no tags.
 * * `setup_complete` - a Module has been created, and at least one ModuleVersion has been
 * successfully uploaded. Scalr assigns this status while some module-versions upload might
 * be still in-progress. If you want to ensure a specific version was uploaded, you can poll
 * [List Module Versions](module-versions.html#list-module-versions) for the `ok` status.
 * * `errored` - Module has been created, however its synchronization has failed. Attribute
 * `error-message` contains the details.
 */
export const status8 = {
    NO_VERSION_TAGS: 'no_version_tags',
    PENDING: 'pending',
    SETUP_COMPLETE: 'setup_complete',
    ERRORED: 'errored',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ModuleDocument = {
    data?: Module;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ModuleListingDocument = {
    data?: Array<Module>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a request to resync the object.
 */
export type ModuleResyncRequest = {
    /**
     * Force resync module. If not equal to "true", only versions that did not exist before
     * will be synchronized.
     */
    force?: boolean;
};

/**
 * Represents terraform module usage namespace instance.
 */
export type ModuleUsageNamespace = {
    attributes?: {
        /**
         * Name of the namespace
         */
        'namespace-name'?: string;
        source?: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The account this usage instance belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * Filled when namespace is a scalr account
         */
        'namespace-account'?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * Namespace of module the Scalr module.
         */
        'namespace-environment'?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
    };
    type: 'tf-module-namespaces';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ModuleUsageNamespaceDocument = {
    data?: ModuleUsageNamespace;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ModuleUsageNamespaceListingDocument = {
    data?: Array<ModuleUsageNamespace>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A terraform module's version in the [Private Module Registry](../../module.html).
 */
export type ModuleVersion = {
    attributes: {
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        /**
         * The list of modules this version depends on.
         */
        readonly dependencies?: {
            [key: string]:
                | string
                | {
                      [key: string]: unknown;
                  }
                | Array<unknown>;
        } | null;
        /**
         * README contents.
         *
         * This file should be named README or README.md. The latter will be processed as
         * [CommonMark](https://commonmark.org/).
         */
        readonly details?: string | null;
        /**
         * This field contains the error description, when this module version's status is
         * `errored`.
         */
        readonly 'error-message'?: string | null;
        /**
         * Input Variables.
         */
        readonly inputs?: Array<RegistryInputOptional | RegistryInputRequired> | null;
        /**
         * Module version marked as root will allow the
         * [creation of workspaces](../../module.html#deployable-modules) directly from the
         * registry, as well as standard module usage.
         */
        readonly 'is-root-module'?: boolean;
        /**
         * Output Values.
         */
        readonly outputs?: Array<{
            description?: string;
            name?: string;
            sensitive?: boolean;
            value?:
                | (
                      | string
                      | {
                            [key: string]: unknown;
                        }
                      | Array<unknown>
                  )
                | null;
        }> | null;
        /**
         * Declared resources.
         */
        readonly resources?: Array<{
            address?: string;
            type?: string;
        }> | null;
        /**
         * A blob size in bytes.
         */
        readonly size?: number | null;
        /**
         * The module version's current status.
         *
         * Initial status:
         * * `not_uploaded` - Module version has been created, however the code has not been
         * uploaded.
         *
         * Transitional statuses:
         * * `pending` - Module version has been created and is currently synchronizing.
         * * `pending_delete` - Module version has been deleted from the repository and pending
         * deletion from the registry.
         *
         * Ending statuses:
         * * `ok` - Module version has been created and the code has been uploaded.
         * * `errored` - Module version has been created, however its synchronization has failed.
         * Attribute `error-message` contains the details.
         */
        readonly status?: 'not_uploaded' | 'pending' | 'ok' | 'errored' | 'pending_delete';
        /**
         * Semantic Version.
         */
        version: string;
    };
    readonly id?: string;
    readonly links?: {
        /**
         * The URL to download the tar.gz archive with module version source code.
         */
        readonly download?: string | null;
        readonly self?: string;
    };
    relationships: {
        /**
         * The module this version belongs to.
         */
        module: {
            data: {
                id: string;
                type: 'modules';
            };
        };
        /**
         * The Git commit information when the module version was uploaded from a VCS.
         */
        readonly 'vcs-revision'?: {
            data: {
                id: string;
                type: 'vcs-revisions';
            } | null;
        };
    };
    type: 'module-versions';
};

/**
 * The module version's current status.
 *
 * Initial status:
 * * `not_uploaded` - Module version has been created, however the code has not been
 * uploaded.
 *
 * Transitional statuses:
 * * `pending` - Module version has been created and is currently synchronizing.
 * * `pending_delete` - Module version has been deleted from the repository and pending
 * deletion from the registry.
 *
 * Ending statuses:
 * * `ok` - Module version has been created and the code has been uploaded.
 * * `errored` - Module version has been created, however its synchronization has failed.
 * Attribute `error-message` contains the details.
 */
export type status9 = 'not_uploaded' | 'pending' | 'ok' | 'errored' | 'pending_delete';

/**
 * The module version's current status.
 *
 * Initial status:
 * * `not_uploaded` - Module version has been created, however the code has not been
 * uploaded.
 *
 * Transitional statuses:
 * * `pending` - Module version has been created and is currently synchronizing.
 * * `pending_delete` - Module version has been deleted from the repository and pending
 * deletion from the registry.
 *
 * Ending statuses:
 * * `ok` - Module version has been created and the code has been uploaded.
 * * `errored` - Module version has been created, however its synchronization has failed.
 * Attribute `error-message` contains the details.
 */
export const status9 = {
    NOT_UPLOADED: 'not_uploaded',
    PENDING: 'pending',
    OK: 'ok',
    ERRORED: 'errored',
    PENDING_DELETE: 'pending_delete',
} as const;

export type type11 = 'modules';

export const type11 = {
    MODULES: 'modules',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ModuleVersionDocument = {
    data?: ModuleVersion;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ModuleVersionListingDocument = {
    data?: Array<ModuleVersion>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * The ability to perform an action on an object, enabling the corresponding functionality
 * in the UI and API. e.g. `workspaces:create`, `vcs-providers:read`.
 *
 * The ID of a permission consist of two parts separated with `:` (colon):
 * * Resource type in a plural form.
 * * Action name. Generally the actions are CRUD, but some objects have specific actions, such as `runs:cancel`.
 *
 * If an `*` (asterisk) is used instead of the action name in the permission it means the permission allows all actions
 * for the specified resource type. For example `workspaces:*` allows all actions with workspaces.
 *
 * An asterisk can be also used instead of the resource type. For example permission `*:read` gives read access to all resources.
 *
 * `*:*` - gives access to everything.
 *
 * Use [List Permissions](permissions.html#list-permissions) to obtain all possible permissions.
 */
export type Permission = {
    attributes?: {
        /**
         * Scope identities, this permission could be applied to in an [access policy](access-policies.html).
         */
        'applicable-scopes'?: Array<'account' | 'environment' | 'workspace'>;
        /**
         * Permission description.
         */
        description?: string | null;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    type: 'permissions';
};

export type type12 = 'permissions';

export const type12 = {
    PERMISSIONS: 'permissions',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PermissionDocument = {
    data?: Permission;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PermissionListingDocument = {
    data?: Array<Permission>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Provides details of a Terraform plan operation.
 */
export type Plan = {
    attributes?: {
        /**
         * Plan execution details.
         */
        'execution-details'?: {
            [key: string]: string;
        };
        /**
         * Indicates if plan has proposed resource changes.
         */
        'has-changes'?: boolean;
        /**
         * The number of new resources that will be added.
         */
        'resource-additions'?: number | null;
        /**
         * The number of resources that will be updated in place.
         */
        'resource-changes'?: number | null;
        /**
         * The number of resources that will be destroyed.
         */
        'resource-destructions'?: number | null;
        /**
         * The Plan's current status.
         *
         * Transient states:
         * * `pending` - Plan has been created but not yet queued.
         * * `queued` - Queued and waiting for capacity/and or quota to be available.
         * * `running` - Running.
         *
         * Final states:
         * * `canceled` - Plan canceled in some way.
         * * `errored` - An error occurred during the plan. See `output` for details.
         * * `finished` - Plan completed successfully.
         * * `unreachable` - Plan will not be run.
         */
        status?: 'pending' | 'queued' | 'running' | 'finished' | 'canceled' | 'errored' | 'unreachable';
        /**
         * Date/Time of transition to each status that has occurred.
         */
        'status-timestamps'?: {
            [key: string]: string;
        };
    };
    readonly id?: string;
    readonly links?: {
        /**
         * URL to retrieve the JSON execution plan
         */
        'json-output'?: string | null;
        /**
         * Link to download the raw output of the terraform plan.
         */
        output?: string | null;
        self?: string;
    };
    type: 'plans';
};

export type type13 = 'plans';

export const type13 = {
    PLANS: 'plans',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PlanDocument = {
    data?: Plan;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A policy provides details of a single OPA policy
 * as declared in [scalr-policy.hcl](../../opa.html#creating-policy-groups).
 */
export type Policy = {
    attributes?: {
        /**
         * If set to `false`, the policy will not be evaluated during a run.
         */
        readonly enabled?: boolean;
        /**
         * The policy's enforcement level.
         *
         * * `hard-mandatory` - cannot be overridden.
         * * `soft-mandatory` - can be overridden through an approval by account admins
         * and other authorized roles.
         * * `advisory` - provides a warning only.
         */
        readonly 'enforced-level'?: 'hard-mandatory' | 'soft-mandatory' | 'advisory';
        /**
         * The name of the policy.
         */
        name?: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The policy group this policy belongs to.
         */
        readonly 'policy-group'?: {
            data: {
                id: string;
                type: 'policy-groups';
            } | null;
        };
    };
    type: 'policies';
};

/**
 * The policy's enforcement level.
 *
 * * `hard-mandatory` - cannot be overridden.
 * * `soft-mandatory` - can be overridden through an approval by account admins
 * and other authorized roles.
 * * `advisory` - provides a warning only.
 */
export type enforced_level = 'hard-mandatory' | 'soft-mandatory' | 'advisory';

/**
 * The policy's enforcement level.
 *
 * * `hard-mandatory` - cannot be overridden.
 * * `soft-mandatory` - can be overridden through an approval by account admins
 * and other authorized roles.
 * * `advisory` - provides a warning only.
 */
export const enforced_level = {
    HARD_MANDATORY: 'hard-mandatory',
    SOFT_MANDATORY: 'soft-mandatory',
    ADVISORY: 'advisory',
} as const;

export type type14 = 'policy-groups';

export const type14 = {
    POLICY_GROUPS: 'policy-groups',
} as const;

/**
 * A policy check contains the details of the policy check phase of a run in Scalr.
 *
 * Policy check is performed immediately after Terraform plan and cost estimation have completed for every run
 * in every workspace, including dry runs, where policies have been linked.
 */
export type PolicyCheck = {
    attributes?: {
        permissions?: {
            [key: string]: unknown;
        };
        /**
         * OPA policy decision.
         */
        result?: {
            /**
             * Number of policy checks that have failed with 'advisory' level.
             */
            'advisory-failed'?: number;
            /**
             * Duration of the policy check operation.
             */
            'duration-ms'?: number;
            /**
             * Number of policy checks that have failed with "hard-mandatory" level.
             */
            'hard-failed'?: number;
            /**
             * Number of policy checks that have passed.
             */
            passed?: number;
            /**
             * List of policies that were checked.
             */
            policies?: Array<{
                messages?: Array<string>;
                name: string;
                result: 'passed' | 'hard_failed' | 'soft_failed' | 'advisory_failed';
            }>;
            /**
             * Indicates whether all policy checks have passed without failures.
             */
            result?: boolean;
            /**
             * Number of policy checks that have failed with "soft-mandatory" level.
             */
            'soft-failed'?: number;
            /**
             * Total number of policy checks that have failed.
             */
            'total-failed'?: number;
        };
        /**
         * The Policy checks's current status.
         *
         * Transient states:
         * * `pending` - The initial status of a policy check once it has been created.
         * * `queued` - The policy check has been queued, awaiting backend service capacity to run terraform.
         * * `running` - The policy check is running.
         * * `soft_failed` Policy check has finished, and run hasn't passed policy with the `soft` level.
         * User having `policy-checks:override` permission can overide the policy check decision,
         * and push this run next to apply.
         *
         * Final states:
         * * `canceled` - The policy check has been canceled.
         * * `errored` - The policy check has finished with an error. Attribute `error-message` contains the details.
         * * `hard_failed` - Run hasn't passed policy with the `hard` level.
         * * `overridden` - The policy check `soft_failed` status has been overriden.
         * * `passed` - Run has successfully passed all configured policies.
         * * `unreachable` - The policy check will not run.
         */
        status?:
            | 'pending'
            | 'queued'
            | 'passed'
            | 'errored'
            | 'hard_failed'
            | 'soft_failed'
            | 'overridden'
            | 'unreachable'
            | 'canceled';
        /**
         * Date/Time of transition to each status that has occurred.
         */
        'status-timestamps'?: {
            [key: string]: string;
        };
    };
    readonly id?: string;
    readonly links?: {
        /**
         * Link to download the policy check raw output.
         */
        output?: string;
    };
    type: 'policy-checks';
};

/**
 * The Policy checks's current status.
 *
 * Transient states:
 * * `pending` - The initial status of a policy check once it has been created.
 * * `queued` - The policy check has been queued, awaiting backend service capacity to run terraform.
 * * `running` - The policy check is running.
 * * `soft_failed` Policy check has finished, and run hasn't passed policy with the `soft` level.
 * User having `policy-checks:override` permission can overide the policy check decision,
 * and push this run next to apply.
 *
 * Final states:
 * * `canceled` - The policy check has been canceled.
 * * `errored` - The policy check has finished with an error. Attribute `error-message` contains the details.
 * * `hard_failed` - Run hasn't passed policy with the `hard` level.
 * * `overridden` - The policy check `soft_failed` status has been overriden.
 * * `passed` - Run has successfully passed all configured policies.
 * * `unreachable` - The policy check will not run.
 */
export type status10 =
    | 'pending'
    | 'queued'
    | 'passed'
    | 'errored'
    | 'hard_failed'
    | 'soft_failed'
    | 'overridden'
    | 'unreachable'
    | 'canceled';

/**
 * The Policy checks's current status.
 *
 * Transient states:
 * * `pending` - The initial status of a policy check once it has been created.
 * * `queued` - The policy check has been queued, awaiting backend service capacity to run terraform.
 * * `running` - The policy check is running.
 * * `soft_failed` Policy check has finished, and run hasn't passed policy with the `soft` level.
 * User having `policy-checks:override` permission can overide the policy check decision,
 * and push this run next to apply.
 *
 * Final states:
 * * `canceled` - The policy check has been canceled.
 * * `errored` - The policy check has finished with an error. Attribute `error-message` contains the details.
 * * `hard_failed` - Run hasn't passed policy with the `hard` level.
 * * `overridden` - The policy check `soft_failed` status has been overriden.
 * * `passed` - Run has successfully passed all configured policies.
 * * `unreachable` - The policy check will not run.
 */
export const status10 = {
    PENDING: 'pending',
    QUEUED: 'queued',
    PASSED: 'passed',
    ERRORED: 'errored',
    HARD_FAILED: 'hard_failed',
    SOFT_FAILED: 'soft_failed',
    OVERRIDDEN: 'overridden',
    UNREACHABLE: 'unreachable',
    CANCELED: 'canceled',
} as const;

export type type15 = 'policy-checks';

export const type15 = {
    POLICY_CHECKS: 'policy-checks',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PolicyCheckDocument = {
    data?: PolicyCheck;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PolicyCheckListingDocument = {
    data?: Array<PolicyCheck>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a terraform policy check result.
 */
export type PolicyCheckResult = {
    attributes?: {
        /**
         * The messages returned by the policy check.
         */
        messages?: Array<string>;
        /**
         * The name of the policy.
         */
        name?: string;
        /**
         * The number of the pull request that triggered the policy check.
         */
        'pull-request-number'?: string | null;
        /**
         * The title of the pull request that triggered the policy check.
         */
        'pull-request-title'?: string | null;
        /**
         * The result of the policy check.
         */
        result?: 'passed' | 'hard_failed' | 'soft_failed' | 'advisory_failed';
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The environment associated with this policy check result.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The policy check this result belongs to.
         */
        'policy-check'?: {
            data: {
                id: string;
                type: 'policy-checks';
            } | null;
        };
        /**
         * The run associated with this policy check result.
         */
        run?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        /**
         * The workspace associated with this policy check result.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'policy-check-results';
};

/**
 * The result of the policy check.
 */
export type result = 'passed' | 'hard_failed' | 'soft_failed' | 'advisory_failed';

/**
 * The result of the policy check.
 */
export const result = {
    PASSED: 'passed',
    HARD_FAILED: 'hard_failed',
    SOFT_FAILED: 'soft_failed',
    ADVISORY_FAILED: 'advisory_failed',
} as const;

export type type16 = 'environments';

export const type16 = {
    ENVIRONMENTS: 'environments',
} as const;

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PolicyCheckResultListingDocument = {
    data?: Array<PolicyCheckResult>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PolicyDocument = {
    data?: Policy;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A policy group represents the collection of [OPA](../../opa.html) policies stored in a VCS
 * repository.
 *
 * When [linked to an environment](environments.html#update-environment),
 * the policy group will participate in the policy check phase of every run in that environment.
 */
export type PolicyGroup = {
    attributes: {
        /**
         * Date/Time the policy group was created.
         */
        readonly 'created-at'?: string;
        /**
         * This field contains the error description when the group's status is `errored`.
         */
        readonly 'error-message'?: string | null;
        /**
         * The stage of the run to evaluate the policy group.
         */
        'execute-as'?: 'pre_plan_check' | 'policy_check';
        /**
         * Indicates whether the policy group is enforced in all environments.
         */
        'is-enforced'?: boolean;
        /**
         * The policy group name must be unique within the account and contain only letters, numbers, dashes
         */
        name: string;
        /**
         * The version of Open Policy Agent to use for the policy evaluation.
         *
         * If omitted, the system default version is assigned.
         */
        'opa-version'?: string;
        /**
         * Policy group current status.
         *
         * * `fetching` - waiting for policies to be synchronized with VCS.
         * * `active` - synchronization completed, policy group is ready.
         * * `errored` - synchronization has failed. Attribute `error-message` contains the details.
         */
        readonly status?: 'fetching' | 'active' | 'errored';
        'vcs-repo': {
            /**
             * Branch of a repository the policy group is associated with.
             * If omitted, the repository default branch will be used.
             */
            branch?: string | null;
            /**
             * A reference to your VCS repository.
             *
             * For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`.
             * For Azure DevOps Services the format is `<org>/<project>/<repo>`.
             */
            identifier: string;
            /**
             * The sub-directory of the VCS repository where OPA policies are stored.
             * The `scalr-policy.hcl` file must exist in this directory.
             * Files and directories outside this directory will be ignored during a sync from VCS,
             * and changing them won't trigger a policy group update.
             *
             * If omitted or submitted as an empty string, this defaults to the repository's root.
             */
            path?: string | null;
        };
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The account this policy group belongs to.
         */
        account: {
            data: {
                id: string;
                type: 'accounts';
            };
        };
        /**
         * List of environments this policy group is linked to.
         */
        readonly environments?: {
            data: Array<{
                id: string;
                type: 'environments';
            }> | null;
        };
        /**
         * List of OPA policies this group contains.
         */
        readonly policies?: {
            data: Array<{
                id: string;
                type: 'policies';
            }> | null;
        };
        /**
         * The policy group's VCS provider.
         */
        'vcs-provider': {
            data: {
                id: string;
                type: 'vcs-providers';
            };
        };
        /**
         * The Git commit information when the policy group was fetched from VCS.
         */
        readonly 'vcs-revision'?: {
            data: {
                id: string;
                type: 'vcs-revisions';
            } | null;
        };
    };
    type: 'policy-groups';
};

/**
 * The stage of the run to evaluate the policy group.
 */
export type execute_as = 'pre_plan_check' | 'policy_check';

/**
 * The stage of the run to evaluate the policy group.
 */
export const execute_as = {
    PRE_PLAN_CHECK: 'pre_plan_check',
    POLICY_CHECK: 'policy_check',
} as const;

/**
 * Policy group current status.
 *
 * * `fetching` - waiting for policies to be synchronized with VCS.
 * * `active` - synchronization completed, policy group is ready.
 * * `errored` - synchronization has failed. Attribute `error-message` contains the details.
 */
export type status11 = 'fetching' | 'active' | 'errored';

/**
 * Policy group current status.
 *
 * * `fetching` - waiting for policies to be synchronized with VCS.
 * * `active` - synchronization completed, policy group is ready.
 * * `errored` - synchronization has failed. Attribute `error-message` contains the details.
 */
export const status11 = {
    FETCHING: 'fetching',
    ACTIVE: 'active',
    ERRORED: 'errored',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PolicyGroupDocument = {
    data?: PolicyGroup;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type PolicyGroupEnvironmentRelationship = {
    id: string;
    type: 'environments';
};

/**
 * Document Listing.
 */
export type PolicyGroupEnvironmentRelationshipFieldsetsListingDocument = {
    data?: Array<PolicyGroupEnvironmentRelationship>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type PolicyGroupListingDocument = {
    data?: Array<PolicyGroup>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * The configuration of provider. Provider configuration is managed on the account scope and can be linked to environments or workspaces.
 */
export type ProviderConfiguration = {
    attributes: {
        /**
         * AWS access key. This option is required with the `access_keys` credential type.
         */
        'aws-access-key'?: string | null;
        /**
         * The type of AWS account, available options: `regular`, `gov-cloud`, `cn-cloud`.
         */
        'aws-account-type'?: ('regular' | 'gov-cloud' | 'cn-cloud') | null;
        /**
         * The value of the aud claim for the identity token.
         */
        'aws-audience'?: string | null;
        /**
         * The type of AWS credential, available options: `access_keys`, `role_delegation`, `oidc`.
         */
        'aws-credentials-type'?: ('role_delegation' | 'access_keys' | 'oidc') | null;
        /**
         * External identifier to use when assuming the role. This option is required with the `role_delegation` credential type.
         */
        'aws-external-id'?: string | null;
        /**
         * Amazon Resource Name (ARN) of the IAM Role to assume. This option is required with the `role_delegation` and `oidc` credential type.
         */
        'aws-role-arn'?: string | null;
        /**
         * AWS secret key. This option is required with the `access_keys` credential type.
         */
        'aws-secret-key'?: string | null;
        /**
         * Trusted entity type, available options: `aws_account`, `aws_service`. This option is required with the `role_delegation` credential type.
         */
        'aws-trusted-entity-type'?: ('aws_account' | 'aws_service') | null;
        /**
         * The value of the aud claim for the identity token.
         */
        'azurerm-audience'?: string | null;
        /**
         * The type of azurerm credentials, available options: `client-secrets`, `oidc`.
         */
        'azurerm-auth-type'?: ('client-secrets' | 'oidc') | null;
        /**
         * The Client ID which should be used.
         */
        'azurerm-client-id'?: string | null;
        /**
         * The Client Secret which should be used.
         */
        'azurerm-client-secret'?: string | null;
        /**
         * The Subscription ID which should be used.
         */
        'azurerm-subscription-id'?: string | null;
        /**
         * The Tenant ID should be used.
         */
        'azurerm-tenant-id'?: string | null;
        /**
         * Contains the error message if the provider configuration is in an `errored` status.
         */
        readonly 'error-message'?: string | null;
        /**
         * Export provider variables into the run environment. This option is available only for built in providers.
         */
        'export-shell-variables'?: boolean;
        /**
         * Authentication type to access GCP.
         */
        'google-auth-type'?: ('service-account-key' | 'oidc') | null;
        /**
         * Service account key file in JSON format.
         */
        'google-credentials'?: string | null;
        /**
         * The default project to manage resources in. If another project is specified on a resource, it will take precedence.
         */
        'google-project'?: string | null;
        /**
         * The service account email Scalr will use when authenticating to GCP.
         */
        'google-service-account-email'?: string | null;
        /**
         * Service account name.
         */
        readonly 'google-service-account-name'?: string | null;
        /**
         * If the project will be enforced.
         */
        'google-use-default-project'?: boolean | null;
        /**
         * The canonical name of the workload identity provider.
         */
        'google-workload-provider-name'?: string | null;
        /**
         * Determines if a provider configuration is custom. Note: custom provider configurations do not support built-in features like exporting as shell variables or on-save validation. Provider configuration will be validated during the run only.
         */
        'is-custom'?: boolean | null;
        /**
         * Indicates whether the provider configuration can be used in any workspace of the account without directly linking it to the environment.
         */
        'is-shared'?: boolean;
        /**
         * The name of a Scalr provider configuration. This field is unique for the account.
         */
        name: string;
        /**
         * The name of a Terraform provider.
         */
        'provider-name': BuiltInProviderTypes | string;
        /**
         * The Scalr hostname which should be used.
         */
        'scalr-hostname'?: string | null;
        /**
         * The Scalr token which should be used.
         */
        'scalr-token'?: string | null;
        /**
         * Provider configuration status. Can be: `active`, `errored`.
         */
        readonly status?: 'active' | 'errored';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The account this provider configuration belongs to.
         */
        account: {
            data: {
                id: string;
                type: 'accounts';
            };
        };
        /**
         * The list of environments attached to the provider configuration. Can be used to bulk link/unlink environments.
         */
        environments?: {
            data: Array<{
                id: string;
                type: 'environments';
            }> | null;
        };
        /**
         * The teams, the provider configuration belongs to.
         */
        owners?: {
            data: Array<{
                id: string;
                type: 'teams';
            }> | null;
        };
        /**
         * The list of arguments for provider configurations.
         */
        readonly parameters?: {
            data: Array<{
                id: string;
                type: 'provider-configuration-parameters';
            }> | null;
        };
    };
    type: 'provider-configurations';
};

/**
 * The type of AWS account, available options: `regular`, `gov-cloud`, `cn-cloud`.
 */
export type aws_account_type = 'regular' | 'gov-cloud' | 'cn-cloud';

/**
 * The type of AWS account, available options: `regular`, `gov-cloud`, `cn-cloud`.
 */
export const aws_account_type = {
    REGULAR: 'regular',
    GOV_CLOUD: 'gov-cloud',
    CN_CLOUD: 'cn-cloud',
} as const;

/**
 * The type of AWS credential, available options: `access_keys`, `role_delegation`, `oidc`.
 */
export type aws_credentials_type = 'role_delegation' | 'access_keys' | 'oidc';

/**
 * The type of AWS credential, available options: `access_keys`, `role_delegation`, `oidc`.
 */
export const aws_credentials_type = {
    ROLE_DELEGATION: 'role_delegation',
    ACCESS_KEYS: 'access_keys',
    OIDC: 'oidc',
} as const;

/**
 * Trusted entity type, available options: `aws_account`, `aws_service`. This option is required with the `role_delegation` credential type.
 */
export type aws_trusted_entity_type = 'aws_account' | 'aws_service';

/**
 * Trusted entity type, available options: `aws_account`, `aws_service`. This option is required with the `role_delegation` credential type.
 */
export const aws_trusted_entity_type = {
    AWS_ACCOUNT: 'aws_account',
    AWS_SERVICE: 'aws_service',
} as const;

/**
 * The type of azurerm credentials, available options: `client-secrets`, `oidc`.
 */
export type azurerm_auth_type = 'client-secrets' | 'oidc';

/**
 * The type of azurerm credentials, available options: `client-secrets`, `oidc`.
 */
export const azurerm_auth_type = {
    CLIENT_SECRETS: 'client-secrets',
    OIDC: 'oidc',
} as const;

/**
 * Authentication type to access GCP.
 */
export type google_auth_type = 'service-account-key' | 'oidc';

/**
 * Authentication type to access GCP.
 */
export const google_auth_type = {
    SERVICE_ACCOUNT_KEY: 'service-account-key',
    OIDC: 'oidc',
} as const;

/**
 * Provider configuration status. Can be: `active`, `errored`.
 */
export type status12 = 'active' | 'errored';

/**
 * Provider configuration status. Can be: `active`, `errored`.
 */
export const status12 = {
    ACTIVE: 'active',
    ERRORED: 'errored',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ProviderConfigurationDocument = {
    data?: ProviderConfiguration;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * The provider configuration link attaches the provider configuration to an environment or workspace.
 */
export type ProviderConfigurationLink = {
    attributes?: {
        /**
         * Is used only for the workspace links. Meta-argument for using the same provider with different configurations for different resources.
         */
        alias?: string | null;
        /**
         * Is used only for the environment links. Indicates whether the provider configuration must be used in every environment workspace during runs without direct linking. This behaviour can be changed in specific workspace by creating direct workspace link without alias.
         */
        readonly default?: boolean;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        readonly environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        'provider-configuration': {
            data: {
                id: string;
                type: 'provider-configurations';
            };
        };
        readonly workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'provider-configuration-links';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ProviderConfigurationLinkDocument = {
    data?: ProviderConfigurationLink;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ProviderConfigurationLinkListingDocument = {
    data?: Array<ProviderConfigurationLink>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ProviderConfigurationListingDocument = {
    data?: Array<ProviderConfiguration>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * The argument of the provider configuration.
 */
export type ProviderConfigurationParameter = {
    attributes: {
        /**
         * Variable description.
         */
        description?: string | null;
        /**
         * Parameter name.
         */
        key: string;
        /**
         * Indicates whether the value is sensitive. When set to `true` then the parameter is not visible after being written.
         */
        sensitive?: boolean;
        /**
         * Parameter value. Not visible if sensitive: true is enabled
         */
        value?: string | null;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        readonly 'provider-configuration'?: {
            data: {
                id: string;
                type: 'provider-configurations';
            } | null;
        };
    };
    type: 'provider-configuration-parameters';
};

export type type17 = 'provider-configurations';

export const type17 = {
    PROVIDER_CONFIGURATIONS: 'provider-configurations',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ProviderConfigurationParameterDocument = {
    data?: ProviderConfigurationParameter;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ProviderConfigurationParameterListingDocument = {
    data?: Array<ProviderConfigurationParameter>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type Reason = {
    /**
     * The reason for locking the workspace.
     */
    reason?: string;
};

export type RegistryInputOptional = {
    default:
        | (
              | boolean
              | number
              | string
              | Array<unknown>
              | {
                    [key: string]: unknown;
                }
          )
        | null;
    description?: string | null;
    name: string;
    sensitive?: boolean;
    type?: string | null;
};

export type RegistryInputRequired = {
    description?: string | null;
    name: string;
    sensitive?: boolean;
    type?: string | null;
};

/**
 * Represents remote state consumers' relationship.
 */
export type RemoteStateConsumerRelationship = {
    id: string;
    type: 'workspaces';
};

export type type18 = 'workspaces';

export const type18 = {
    WORKSPACES: 'workspaces',
} as const;

/**
 * Document Listing.
 */
export type RemoteStateConsumerRelationshipFieldsetsListingDocument = {
    data?: Array<RemoteStateConsumerRelationship>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A collection of permissions that can be assigned to a user, team, or service account via an [access policy](access-policies.html).
 */
export type Role = {
    attributes: {
        /**
         * The description of the role.
         */
        description?: string | null;
        /**
         * When `true` the role is built-in, and cannot be modified or deleted.
         */
        readonly 'is-system'?: boolean;
        /**
         * The name of the role.
         */
        name: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account this role belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * The collection of [permissions](permissions.html)
         */
        permissions?: {
            data: Array<{
                id: string;
                type: 'permissions';
            }> | null;
        };
    };
    type: 'roles';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type RoleDocument = {
    data?: Role;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type RoleListingDocument = {
    data?: Array<Role>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A Run provides details of an entire run operation potentially comprising `plan`, `cost-estimation`,
 * `policy-check` and `apply`.
 */
export type Run = {
    attributes?: {
        /**
         * The UTC datetime at which the Apply should be queued.
         */
        readonly 'apply-at'?: string | null;
        /**
         * Indicates whether `terraform apply` should automatically run
         * when terraform plan ends without error.
         * Defaults to the current Auto Apply setting in the workspace.
         */
        'auto-apply'?: boolean;
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        /**
         * Contains error message, when the run has finished in `errored` status.
         */
        readonly 'error-message'?: string | null;
        /**
         * Specifies whether the plan has proposed resource changes.
         */
        readonly 'has-changes'?: boolean;
        /**
         * The IaC platform for the run.
         */
        readonly 'iac-platform'?: 'terraform' | 'opentofu';
        /**
         * Terraform input variables that were passed into the workspace.
         */
        inputs?: Array<{
            description?: string;
            name?: string;
            sensitive?: boolean;
            value?:
                | (
                      | boolean
                      | number
                      | string
                      | Array<unknown>
                      | {
                            [key: string]: unknown;
                        }
                  )
                | null;
        }> | null;
        /**
         * Indicates if this run is a destroy that will destroy all provisioned infrastructure
         * in the current state.
         */
        'is-destroy'?: boolean;
        'is-dry'?: boolean;
        /**
         * Specifies the explanation message to associate with the run.
         */
        message?: string | null;
        readonly permissions?: {
            [key: string]: unknown;
        };
        /**
         * The UTC datetime at which the Plan should be queued.
         */
        'plan-at'?: string | null;
        readonly 'position-in-queue'?: number | null;
        /**
         * Specifies whether or not to refresh the state before a plan.
         */
        refresh?: boolean | null;
        /**
         * Specifies whether this run should use the refresh-only plan mode.
         */
        'refresh-only'?: boolean | null;
        /**
         * Specifies an optional list of resource addresses to force replacement of a particular resource. If the plan would've normally produced an update or no-op action for this instance, Terraform will plan to replace it instead.
         */
        'replace-addrs'?: Array<string> | null;
        /**
         * The origin of the run.
         */
        source?: Sources | string;
        /**
         * The Run's current status.
         *
         * Initial status:
         * * `pending` -  The initial status of a run once it has been created. Scalr processes each workspace's
         * runs in the order they were queued, and a run remains pending until every run before it has completed.
         * The exception are Runs having `is-dry: true`. Such runs don't modify a workspace's state, and could
         * run in a parallel until the account's runs quota limit.
         *
         * Plan stage:
         * * `plan_queued` - The plan is queued and waiting for capacity/and or quota to be available.
         * * `planning` - Scalr is currently running `terraform plan`.
         * * `planned` - `terraform plan` has finished. If the run's  workspace has `auto-apply: false`,
         * Scalr pauses the run in this state, awaiting confirmation.
         * * `confirmed` - Run has been confirmed to apply.
         *
         * Cost estimate stage (optional):
         * * `cost_estimating` - Scalr is currently calculating the cost estimate for the plan.
         * * `cost_estimated` - The cost estimation stage has finished.
         *
         * Policy check stage (optional):
         * * `policy_checking` - Scalr is currently checking the plan against the environment's policies.
         * * `policy_checked` -  The policy check succeeded, and Policy Engine will allow an apply to proceed.
         * Scalr sometimes pauses in this state, depending on workspace settings.
         * * `policy_override` - The policy check finished, but at least one `soft-mandatory` policy failed, so an
         * apply cannot proceed without approval from a user having `policy-checks:override` permission.
         * The run pauses in this state.
         *
         * Apply stage:
         * * `apply_queued` -  The apply is queued and waiting for capacity/and or quota to be available.
         * * `applying` - Scalr is currently running `terraform apply`.
         * * `applied` - Scalr has successfully finished applying.
         *
         * Ending statuses:
         * * `planned_and_finished` - Dry run's pipeline of Plan -> CostEstimate -> PolicyCheck stages have finished.
         * This is the final state for dry run.
         * * `errored` - The run has finished with an error. The attribute `error-message` has the details.
         * * `discarded` - A user chose not to continue this run from a confirmation state
         * * `canceled` -  A user interrupted the run from any active stage.
         */
        readonly status?:
            | 'pending'
            | 'pre_plan_queued'
            | 'pre_plan_running'
            | 'pre_plan_finished'
            | 'plan_queued'
            | 'planning'
            | 'planned'
            | 'confirmed'
            | 'discarded'
            | 'planned_and_finished'
            | 'post_plan_running'
            | 'post_plan_finished'
            | 'cost_estimating'
            | 'cost_estimated'
            | 'policy_checking'
            | 'policy_override'
            | 'policy_checked'
            | 'pre_apply_queued'
            | 'pre_apply_running'
            | 'pre_apply_finished'
            | 'apply_queued'
            | 'applying'
            | 'applied'
            | 'post_apply_running'
            | 'post_apply_finished'
            | 'errored'
            | 'canceled';
        /**
         * Timestamps of transition to prior and current statuses.
         */
        readonly 'status-timestamps'?: {
            [key: string]: string;
        };
        /**
         * If non-empty, requests that Terraform should create a plan including actions only for the given objects (specified using resource address syntax) and the objects they depend on.
         */
        'target-addrs'?: Array<string> | null;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * Terraform apply phase.
         */
        readonly apply?: {
            data: {
                id: string;
                type: 'applies';
            } | null;
        };
        /**
         * The Run's configuration version.
         */
        'configuration-version'?: {
            data: {
                id: string;
                type: 'configuration-versions';
            } | null;
        };
        /**
         * Cost estimation phase.
         */
        readonly 'cost-estimate'?: {
            data: {
                id: string;
                type: 'cost-estimates';
            } | null;
        };
        /**
         * User that has triggered the run.
         */
        readonly 'created-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * Upstream Run that has triggered this run.
         */
        'created-by-run'?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        /**
         * The environment this run Run belongs to.
         */
        readonly environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * Terraform plan phase.
         */
        readonly plan?: {
            data: {
                id: string;
                type: 'plans';
            } | null;
        };
        /**
         * Policy check phase.
         */
        readonly 'policy-checks'?: {
            data: Array<{
                id: string;
                type: 'policy-checks';
            }> | null;
        };
        /**
         * The run's state versions.
         */
        readonly 'state-versions'?: {
            data: Array<{
                id: string;
                type: 'state-versions';
            }> | null;
        };
        /**
         * Date/Time of transition to each status that has occurred.
         */
        readonly 'status-transitions'?: {
            data: Array<{
                id: string;
                type: 'status-transitions';
            }> | null;
        };
        readonly tags?: {
            data: Array<{
                id: string;
                type: 'tags';
            }> | null;
        };
        /**
         * Relation to the Git commit information, when the run's `configuration-version` source is `vcs`
         */
        readonly 'vcs-revision'?: {
            data: {
                id: string;
                type: 'vcs-revisions';
            } | null;
        };
        /**
         * The workspace this Run belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'runs';
};

/**
 * The IaC platform for the run.
 */
export type iac_platform = 'terraform' | 'opentofu';

/**
 * The IaC platform for the run.
 */
export const iac_platform = {
    TERRAFORM: 'terraform',
    OPENTOFU: 'opentofu',
} as const;

/**
 * The Run's current status.
 *
 * Initial status:
 * * `pending` -  The initial status of a run once it has been created. Scalr processes each workspace's
 * runs in the order they were queued, and a run remains pending until every run before it has completed.
 * The exception are Runs having `is-dry: true`. Such runs don't modify a workspace's state, and could
 * run in a parallel until the account's runs quota limit.
 *
 * Plan stage:
 * * `plan_queued` - The plan is queued and waiting for capacity/and or quota to be available.
 * * `planning` - Scalr is currently running `terraform plan`.
 * * `planned` - `terraform plan` has finished. If the run's  workspace has `auto-apply: false`,
 * Scalr pauses the run in this state, awaiting confirmation.
 * * `confirmed` - Run has been confirmed to apply.
 *
 * Cost estimate stage (optional):
 * * `cost_estimating` - Scalr is currently calculating the cost estimate for the plan.
 * * `cost_estimated` - The cost estimation stage has finished.
 *
 * Policy check stage (optional):
 * * `policy_checking` - Scalr is currently checking the plan against the environment's policies.
 * * `policy_checked` -  The policy check succeeded, and Policy Engine will allow an apply to proceed.
 * Scalr sometimes pauses in this state, depending on workspace settings.
 * * `policy_override` - The policy check finished, but at least one `soft-mandatory` policy failed, so an
 * apply cannot proceed without approval from a user having `policy-checks:override` permission.
 * The run pauses in this state.
 *
 * Apply stage:
 * * `apply_queued` -  The apply is queued and waiting for capacity/and or quota to be available.
 * * `applying` - Scalr is currently running `terraform apply`.
 * * `applied` - Scalr has successfully finished applying.
 *
 * Ending statuses:
 * * `planned_and_finished` - Dry run's pipeline of Plan -> CostEstimate -> PolicyCheck stages have finished.
 * This is the final state for dry run.
 * * `errored` - The run has finished with an error. The attribute `error-message` has the details.
 * * `discarded` - A user chose not to continue this run from a confirmation state
 * * `canceled` -  A user interrupted the run from any active stage.
 */
export type status13 =
    | 'pending'
    | 'pre_plan_queued'
    | 'pre_plan_running'
    | 'pre_plan_finished'
    | 'plan_queued'
    | 'planning'
    | 'planned'
    | 'confirmed'
    | 'discarded'
    | 'planned_and_finished'
    | 'post_plan_running'
    | 'post_plan_finished'
    | 'cost_estimating'
    | 'cost_estimated'
    | 'policy_checking'
    | 'policy_override'
    | 'policy_checked'
    | 'pre_apply_queued'
    | 'pre_apply_running'
    | 'pre_apply_finished'
    | 'apply_queued'
    | 'applying'
    | 'applied'
    | 'post_apply_running'
    | 'post_apply_finished'
    | 'errored'
    | 'canceled';

/**
 * The Run's current status.
 *
 * Initial status:
 * * `pending` -  The initial status of a run once it has been created. Scalr processes each workspace's
 * runs in the order they were queued, and a run remains pending until every run before it has completed.
 * The exception are Runs having `is-dry: true`. Such runs don't modify a workspace's state, and could
 * run in a parallel until the account's runs quota limit.
 *
 * Plan stage:
 * * `plan_queued` - The plan is queued and waiting for capacity/and or quota to be available.
 * * `planning` - Scalr is currently running `terraform plan`.
 * * `planned` - `terraform plan` has finished. If the run's  workspace has `auto-apply: false`,
 * Scalr pauses the run in this state, awaiting confirmation.
 * * `confirmed` - Run has been confirmed to apply.
 *
 * Cost estimate stage (optional):
 * * `cost_estimating` - Scalr is currently calculating the cost estimate for the plan.
 * * `cost_estimated` - The cost estimation stage has finished.
 *
 * Policy check stage (optional):
 * * `policy_checking` - Scalr is currently checking the plan against the environment's policies.
 * * `policy_checked` -  The policy check succeeded, and Policy Engine will allow an apply to proceed.
 * Scalr sometimes pauses in this state, depending on workspace settings.
 * * `policy_override` - The policy check finished, but at least one `soft-mandatory` policy failed, so an
 * apply cannot proceed without approval from a user having `policy-checks:override` permission.
 * The run pauses in this state.
 *
 * Apply stage:
 * * `apply_queued` -  The apply is queued and waiting for capacity/and or quota to be available.
 * * `applying` - Scalr is currently running `terraform apply`.
 * * `applied` - Scalr has successfully finished applying.
 *
 * Ending statuses:
 * * `planned_and_finished` - Dry run's pipeline of Plan -> CostEstimate -> PolicyCheck stages have finished.
 * This is the final state for dry run.
 * * `errored` - The run has finished with an error. The attribute `error-message` has the details.
 * * `discarded` - A user chose not to continue this run from a confirmation state
 * * `canceled` -  A user interrupted the run from any active stage.
 */
export const status13 = {
    PENDING: 'pending',
    PRE_PLAN_QUEUED: 'pre_plan_queued',
    PRE_PLAN_RUNNING: 'pre_plan_running',
    PRE_PLAN_FINISHED: 'pre_plan_finished',
    PLAN_QUEUED: 'plan_queued',
    PLANNING: 'planning',
    PLANNED: 'planned',
    CONFIRMED: 'confirmed',
    DISCARDED: 'discarded',
    PLANNED_AND_FINISHED: 'planned_and_finished',
    POST_PLAN_RUNNING: 'post_plan_running',
    POST_PLAN_FINISHED: 'post_plan_finished',
    COST_ESTIMATING: 'cost_estimating',
    COST_ESTIMATED: 'cost_estimated',
    POLICY_CHECKING: 'policy_checking',
    POLICY_OVERRIDE: 'policy_override',
    POLICY_CHECKED: 'policy_checked',
    PRE_APPLY_QUEUED: 'pre_apply_queued',
    PRE_APPLY_RUNNING: 'pre_apply_running',
    PRE_APPLY_FINISHED: 'pre_apply_finished',
    APPLY_QUEUED: 'apply_queued',
    APPLYING: 'applying',
    APPLIED: 'applied',
    POST_APPLY_RUNNING: 'post_apply_running',
    POST_APPLY_FINISHED: 'post_apply_finished',
    ERRORED: 'errored',
    CANCELED: 'canceled',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type RunDocument = {
    data?: Run;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type RunListingDocument = {
    data?: Array<Run>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A RunScheduleRule resource represents a rule for scheduling runs in a workspace.
 *
 * Each RunScheduleRule is associated with a workspace and has a schedule and a schedule mode.
 * The schedule is a cron expression that determines when runs should be triggered.
 * The schedule mode determines whether the triggered run is an 'apply' 'destroy' or 'refresh' run.
 */
export type RunScheduleRule = {
    attributes?: {
        /**
         * Cron expression for scheduled runs. Time should be in UTC.
         */
        schedule?: string;
        /**
         * Mode of the scheduled run.
         */
        'schedule-mode'?: 'apply' | 'destroy' | 'refresh';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * Workspace in which new runs will be created.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'run-schedule-rules';
};

/**
 * Mode of the scheduled run.
 */
export type schedule_mode = 'apply' | 'destroy' | 'refresh';

/**
 * Mode of the scheduled run.
 */
export const schedule_mode = {
    APPLY: 'apply',
    DESTROY: 'destroy',
    REFRESH: 'refresh',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type RunScheduleRuleDocument = {
    data?: RunScheduleRule;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type RunScheduleRuleListingDocument = {
    data?: Array<RunScheduleRule>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Run triggers allow runs to queue automatically in downstream workspace on
 * successful apply of runs in any of the upstream workspaces.
 */
export type RunTrigger = {
    attributes?: {
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * Downstream workspace in which new runs will be created.
         */
        downstream: {
            data: {
                id: string;
                type: 'workspaces';
            };
        };
        /**
         * Upstream workspace to track new runs.
         */
        upstream: {
            data: {
                id: string;
                type: 'workspaces';
            };
        };
    };
    type: 'run-triggers';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type RunTriggerDocument = {
    data?: RunTrigger;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type SamlIntegration = {
    attributes: {
        /**
         * If enabled, user will be redirected to IdP's login page.
         */
        'auto-redirect'?: boolean | null;
        /**
         * Base URL to construct SAML endpoints from. It needs to be a URL with the protocol, server, port and context path.
         */
        'base-url'?: string | null;
        /**
         * Enables debug mode.
         */
        debug?: boolean;
        /**
         * A message from an IdP that indicates a nature of the problem
         */
        readonly 'error-message'?: string | null;
        /**
         * Instead of using the whole x509cert you can use a fingerprint in order to validate the SAMLResponse, but we don't recommend to use this method on production since is exploitable by collision attack.
         */
        'idp-cert-fingerprint'?: string | null;
        /**
         * IDP cert fingerprint algorithm
         */
        'idp-cert-fingerprint-algorithm'?: string;
        /**
         * Identifier of the IdP entity (must be a URI).
         */
        'idp-entity-id': string;
        /**
         * SAML protocol binding to be used when returning the response message (urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect).
         */
        'idp-single-logout-service-binding'?: string | null;
        /**
         * URL location of IdP where SLO Response will be sent.
         */
        'idp-single-logout-service-response-url'?: string | null;
        /**
         * URL target of IdP where Scalr will send the SLO Request.
         */
        'idp-single-logout-service-url'?: string | null;
        /**
         * SAML protocol binding to be used when returning the response message (urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect).
         */
        'idp-single-sign-on-service-binding'?: string | null;
        /**
         * URL target of IdP where Scalr will send the Authentication Request Message.
         */
        'idp-single-sign-on-service-url': string;
        /**
         * Public x509 certificate of the IdP.
         */
        'idp-x509cert'?: string | null;
        /**
         * IDP x509cert multi encryption
         */
        'idp-x509cert-multi-encryption'?: string | null;
        /**
         * In some scenarios IdP uses different certificates for signing/encryption, or is under key rollover phase and more than one certificate is published on IdP metadata. (when used, 'IdP x509cert' and 'IdP Cert Fingerprint' values are ignored)
         */
        'idp-x509cert-multi-signing'?: string | null;
        /**
         * Whether this SAML IdP is in use.
         */
        readonly 'is-used'?: boolean;
        /**
         * Account type.
         */
        'mapping-azure-aad-account-type'?: string | null;
        /**
         * Client ID.
         */
        'mapping-azure-aad-client-id'?: string | null;
        /**
         * Use Azure Active Directory.
         */
        'mapping-azure-aad-enabled'?: boolean;
        /**
         * Secret key.
         */
        'mapping-azure-aad-secret-key'?: string | null;
        /**
         * Tenant ID.
         */
        'mapping-azure-aad-tenant-id'?: string | null;
        /**
         * Email attribute, in case usernames and emails are different.
         */
        'mapping-email'?: string | null;
        /**
         * Display name attribute.
         */
        'mapping-fullname'?: string | null;
        /**
         * The name of the Groups attribute to use in SAML Assertion.
         */
        'mapping-groups'?: string | null;
        /**
         * Groups separator
         */
        'mapping-separator'?: string | null;
        /**
         * Name of SAML integration
         */
        name: string;
        /**
         * If true, it will not raise an error when the Statement Element contains attribute elements with name duplicated.
         */
        'security-allow-repeat-attribute-name'?: boolean;
        /**
         * Indicates whether the <samlp:AuthnRequest> messages sent by Scalr will be signed.
         */
        'security-authn-requests-signed'?: boolean;
        /**
         * Algorithm that Scalr will use on digest process.
         */
        'security-digest-algorithm'?:
            | (
                  | 'http://www.w3.org/2001/04/xmlenc#sha256'
                  | 'http://www.w3.org/2001/04/xmldsig-more#sha384'
                  | 'http://www.w3.org/2001/04/xmlenc#sha512'
              )
            | null;
        /**
         * Indicates whether the <samlp:logoutRequest> messages sent by Scalr will be signed.
         */
        'security-logout-request-signed'?: boolean;
        /**
         * Indicates whether the <samlp:logoutResponse> messages sent by Scalr will be signed.
         */
        'security-logout-response-signed'?: boolean;
        /**
         * Indicates that the nameID of the <samlp:logoutRequest> sent by Scalr will be encrypted.
         */
        'security-name-id-encrypted'?: boolean;
        /**
         * Leave empty and no AuthContext will be sent in the AuthNRequest,Set an array with the possible auth context values: ["urn:oasis:names:tc:SAML:2.0:ac:classes:Password", "urn:oasis:names:tc:SAML:2.0:ac:classes:X509"]
         */
        'security-requested-authn-context'?: string;
        /**
         * Allows the authn comparison parameter to be set.
         */
        'security-requested-authn-context-comparison'?: 'exact' | 'minimum' | 'better' | 'maximum';
        /**
         * Sign the Metadata. If enabled SP certificate must be provided.
         */
        'security-sign-metadata'?: boolean | null;
        /**
         * Algorithm that Scalr will use on signing process.
         */
        'security-signature-algorithm'?:
            | 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256'
            | 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384'
            | 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512';
        /**
         * Indicates a requirement for the <saml:Assertion> elements received by Scalr to be encrypted.
         */
        'security-want-assertions-encrypted'?: boolean;
        /**
         * Indicates a requirement for the <saml:Assertion> elements received by Scalr to be signed.
         */
        'security-want-assertions-signed'?: boolean;
        /**
         * Indicates a requirement for the <samlp:Response>, <samlp:LogoutRequest> and <samlp:LogoutResponse> elements received by Scalr to be signed.
         */
        'security-want-messages-signed'?: boolean;
        /**
         * Indicates a requirement for the NameID element on the SAMLResponse received by this SP to be present.
         */
        'security-want-name-id'?: boolean;
        /**
         * Indicates a requirement for the NameID received by Scalr to be encrypted.
         */
        'security-want-name-id-encrypted'?: boolean;
        /**
         * SAML protocol binding to be used when returning the response message. It supports HTTP-POST binding only.
         */
        'sp-assertion-consumer-service-binding'?: string;
        readonly 'sp-default-entity-id'?: string;
        /**
         * Service provider entity identifier
         */
        'sp-entity-id'?: string;
        /**
         * SP name id format
         */
        'sp-name-id-format'?: string;
        /**
         * SP private key
         */
        'sp-private-key'?: string | null;
        /**
         * SP single logout service binding
         */
        'sp-single-logout-service-binding'?: string;
        /**
         * SP x509cert
         */
        'sp-x509cert'?: string | null;
        /**
         * SP x509cert new
         */
        'sp-x509cert-new'?: string | null;
        /**
         * Status of SAML integration.
         */
        status?: 'active' | 'disabled' | 'failed';
        /**
         * If enabled, Scalr will reject unsigned or unencrypted messages when expects them to be signed or encrypted.
         */
        strict?: boolean;
        'use-identifier-in-urls'?: boolean;
        /**
         * Represents the verification status with the IdP SAML provider)
         */
        readonly 'verification-status'?: 'pending' | 'success' | 'running';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account this SAML integration belongs to.
         */
        readonly account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
    };
    type: 'saml-integration';
};

/**
 * Algorithm that Scalr will use on digest process.
 */
export type security_digest_algorithm =
    | 'http://www.w3.org/2001/04/xmlenc#sha256'
    | 'http://www.w3.org/2001/04/xmldsig-more#sha384'
    | 'http://www.w3.org/2001/04/xmlenc#sha512';

/**
 * Algorithm that Scalr will use on digest process.
 */
export const security_digest_algorithm = {
    HTTP___WWW_W3_ORG_2001_04_XMLENC_SHA256: 'http://www.w3.org/2001/04/xmlenc#sha256',
    HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_SHA384: 'http://www.w3.org/2001/04/xmldsig-more#sha384',
    HTTP___WWW_W3_ORG_2001_04_XMLENC_SHA512: 'http://www.w3.org/2001/04/xmlenc#sha512',
} as const;

/**
 * Allows the authn comparison parameter to be set.
 */
export type security_requested_authn_context_comparison = 'exact' | 'minimum' | 'better' | 'maximum';

/**
 * Allows the authn comparison parameter to be set.
 */
export const security_requested_authn_context_comparison = {
    EXACT: 'exact',
    MINIMUM: 'minimum',
    BETTER: 'better',
    MAXIMUM: 'maximum',
} as const;

/**
 * Algorithm that Scalr will use on signing process.
 */
export type security_signature_algorithm =
    | 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256'
    | 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384'
    | 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512';

/**
 * Algorithm that Scalr will use on signing process.
 */
export const security_signature_algorithm = {
    HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_RSA_SHA256: 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256',
    HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_RSA_SHA384: 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384',
    HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_RSA_SHA512: 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type SamlIntegrationDocument = {
    data?: SamlIntegration;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type SamlIntegrationListingDocument = {
    data?: Array<SamlIntegration>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a service account definition.
 *
 * A service account is a special type of account intended to represent a non-human user
 * that needs to authenticate and be authorized to access data in Scalr APIs.
 */
export type ServiceAccount = {
    attributes?: {
        readonly 'created-at'?: string;
        /**
         * The service account description.
         */
        description?: string | null;
        /**
         * A read-only field which is generated when a service account is created. Consists of `<name>@<account-domain>.scalr.io`
         */
        readonly email?: string;
        /**
         * The service account name. The service account email will be created using this name.
         */
        name?: string;
        /**
         * The service account status. Can be: `Active`, `Inactive`.
         */
        status?: 'Active' | 'Inactive';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The account ID, the service account belongs to.
         */
        account: {
            data: {
                id: string;
                type: 'accounts';
            };
        };
        /**
         * The user who created the service account.
         */
        readonly 'created-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * The teams, the service account belongs to.
         */
        owners?: {
            data: Array<{
                id: string;
                type: 'teams';
            }> | null;
        };
    };
    type: 'service-accounts';
};

/**
 * The service account status. Can be: `Active`, `Inactive`.
 */
export type status14 = 'Active' | 'Inactive';

/**
 * The service account status. Can be: `Active`, `Inactive`.
 */
export const status14 = {
    ACTIVE: 'Active',
    INACTIVE: 'Inactive',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ServiceAccountDocument = {
    data?: ServiceAccount;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type ServiceAccountListingDocument = {
    data?: Array<ServiceAccount>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type SlackChannel = {
    id: string;
    'is-private': boolean;
    name: string;
};

/**
 * Document Listing.
 */
export type SlackChannelFieldsetsListingDocument = {
    data?: Array<SlackChannel>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type SlackConnection = {
    attributes?: {
        /**
         * The name of connected Slack workspace.
         */
        'slack-workspace-name'?: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The account this connection belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
    };
    type: 'slack-connections';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type SlackConnectionDocument = {
    data?: SlackConnection;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type SlackIntegration = {
    attributes: {
        /**
         * A Slack channel ID to which to send messages.
         */
        'channel-id': string;
        /**
         * Message from service that points to nature of a problem
         */
        readonly 'err-message'?: string | null;
        /**
         * Events for which to get notifications.
         */
        events?: Array<'run_approval_required' | 'run_success' | 'run_errored'>;
        /**
         * Whether to notify about success or failure from the apply step only
         */
        'is-apply-only'?: boolean;
        /**
         * Name of Slack integration
         */
        name: string;
        /**
         * What type of runs should be reported.
         */
        'run-mode'?: 'all' | 'apply' | 'dry';
        /**
         * Status of integration.
         */
        status?: 'active' | 'disabled' | 'failed';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The account this integration belongs to.
         */
        account: {
            data: {
                id: string;
                type: 'accounts';
            };
        };
        /**
         * Associated Slack App connection.
         */
        connection: {
            data: {
                id: string;
                type: 'slack-connections';
            };
        };
        /**
         * Environments source of events.
         */
        environments: {
            data: Array<{
                id: string;
                type: 'environments';
            }>;
        };
        /**
         * Workspaces source of events.
         */
        workspaces?: {
            data: Array<{
                id: string;
                type: 'workspaces';
            }> | null;
        };
    };
    type: 'slack-integrations';
};

/**
 * What type of runs should be reported.
 */
export type run_mode = 'all' | 'apply' | 'dry';

/**
 * What type of runs should be reported.
 */
export const run_mode = {
    ALL: 'all',
    APPLY: 'apply',
    DRY: 'dry',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type SlackIntegrationDocument = {
    data?: SlackIntegration;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type SlackIntegrationListingDocument = {
    data?: Array<SlackIntegration>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a software version.
 */
export type SoftwareVersion = {
    attributes: {
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        /**
         * Default version to use when workspace or policy-group creation request
         * doesn't specify a version.
         */
        readonly default?: boolean;
        /**
         * Indicates that this software-version is deprecated,
         * and thus not available for new workspaces or policy-groups.
         */
        deprecated?: boolean;
        /**
         * This field contains the error description,
         * when this software-version's status is `failed`.
         */
        readonly error?: string | null;
        /**
         * Container image SHA256 hash.
         */
        readonly hash?: string | null;
        /**
         * Reference to a container image in OCI registry.
         * Only public registries supported ATM.
         */
        image: string;
        /**
         * Indicates that this software-version is the latest one
         * for the given software-type.
         */
        readonly latest?: boolean;
        /**
         * The type of the software.
         */
        'software-type': 'opa' | 'terraform' | 'infracost' | 'opentofu';
        /**
         * The software version status.
         *
         * * `pending` - Image is not pulled yet.
         * * `failed` - Image pull ended with a failure. Attribute `error` contains the details.
         * * `active` - Available to use.
         */
        readonly status?: 'pending' | 'failed' | 'active';
        /**
         * Semantic Version.
         */
        version: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    type: 'software-versions';
};

/**
 * The type of the software.
 */
export type software_type = 'opa' | 'terraform' | 'infracost' | 'opentofu';

/**
 * The type of the software.
 */
export const software_type = {
    OPA: 'opa',
    TERRAFORM: 'terraform',
    INFRACOST: 'infracost',
    OPENTOFU: 'opentofu',
} as const;

/**
 * The software version status.
 *
 * * `pending` - Image is not pulled yet.
 * * `failed` - Image pull ended with a failure. Attribute `error` contains the details.
 * * `active` - Available to use.
 */
export type status15 = 'pending' | 'failed' | 'active';

/**
 * The software version status.
 *
 * * `pending` - Image is not pulled yet.
 * * `failed` - Image pull ended with a failure. Attribute `error` contains the details.
 * * `active` - Available to use.
 */
export const status15 = {
    PENDING: 'pending',
    FAILED: 'failed',
    ACTIVE: 'active',
} as const;

export type type19 = 'software-versions';

export const type19 = {
    SOFTWARE_VERSIONS: 'software-versions',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type SoftwareVersionDocument = {
    data?: SoftwareVersion;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type SoftwareVersionListingDocument = {
    data?: Array<SoftwareVersion>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type Sources =
    | 'api'
    | 'cli'
    | 'scalr-cli'
    | 'configuration-version'
    | 'service-catalog'
    | 'ui'
    | 'vcs'
    | 'vcs-task'
    | 'run-trigger'
    | 'schedule'
    | 'restart'
    | 'restart-ci'
    | 'assistant'
    | 'dashboard-run'
    | 'dashboard-workspace'
    | 'workspaces-environment'
    | 'workspaces-environment-bulk'
    | 'workspaces-account'
    | 'workspaces-account-bulk'
    | 'reports-iac-versions'
    | 'reports-stale-workspaces'
    | 'auto-destroy'
    | 'comment-github';

export const Sources = {
    API: 'api',
    CLI: 'cli',
    SCALR_CLI: 'scalr-cli',
    CONFIGURATION_VERSION: 'configuration-version',
    SERVICE_CATALOG: 'service-catalog',
    UI: 'ui',
    VCS: 'vcs',
    VCS_TASK: 'vcs-task',
    RUN_TRIGGER: 'run-trigger',
    SCHEDULE: 'schedule',
    RESTART: 'restart',
    RESTART_CI: 'restart-ci',
    ASSISTANT: 'assistant',
    DASHBOARD_RUN: 'dashboard-run',
    DASHBOARD_WORKSPACE: 'dashboard-workspace',
    WORKSPACES_ENVIRONMENT: 'workspaces-environment',
    WORKSPACES_ENVIRONMENT_BULK: 'workspaces-environment-bulk',
    WORKSPACES_ACCOUNT: 'workspaces-account',
    WORKSPACES_ACCOUNT_BULK: 'workspaces-account-bulk',
    REPORTS_IAC_VERSIONS: 'reports-iac-versions',
    REPORTS_STALE_WORKSPACES: 'reports-stale-workspaces',
    AUTO_DESTROY: 'auto-destroy',
    COMMENT_GITHUB: 'comment-github',
} as const;

/**
 * A State version is the version of a state file associated with a workspace.
 */
export type StateVersion = {
    attributes?: {
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        force?: boolean;
        /**
         * Lineage of the state version. Should match the lineage extracted from the `terraform.tfstate`.
         */
        lineage?: string | null;
        /**
         * The MD5 hash of the terraform.tfstate.
         */
        md5?: string;
        /**
         * The list of modules.
         */
        readonly modules?: {
            [key: string]: {
                [key: string]: number;
            };
        };
        /**
         * The list of output values.
         */
        readonly outputs?: Array<{
            name?: string;
            sensitive?: boolean;
            value?:
                | (
                      | string
                      | {
                            [key: string]: unknown;
                        }
                      | Array<unknown>
                  )
                | null;
        }> | null;
        /**
         * The list of providers.
         */
        readonly providers?: {
            [key: string]: {
                [key: string]: number;
            };
        };
        /**
         * The list of resources.
         */
        readonly resources?: Array<{
            address?: string;
            index?: (string | number) | null;
            module?: string | null;
            type?: string;
        }>;
        /**
         * The serial of the state version which must match the `serial` value from the `terraform.tfstate`.
         */
        serial?: number;
        /**
         * Size of the `terraform.tfstate` in bytes.
         */
        readonly size?: number;
        /**
         * Base64 encoded `terraform.tfstate`
         */
        state?: string | null;
    };
    readonly id?: string;
    readonly links?: {
        /**
         * The URL to download the `terraform.tfstate`.
         */
        readonly download?: string | null;
        readonly self?: string;
    };
    relationships?: {
        /**
         * Next state version for the workspace to which state version is associated.
         */
        readonly 'next-state-version'?: {
            data: {
                id: string;
                type: 'state-versions';
            } | null;
        };
        /**
         * Previous state version for the workspace to which state version is associated.
         */
        readonly 'previous-state-version'?: {
            data: {
                id: string;
                type: 'state-versions';
            } | null;
        };
        /**
         * The optional run associated with the state version.
         */
        run?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        /**
         * The workspace, this state version belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'state-versions';
};

export type type20 = 'state-versions';

export const type20 = {
    STATE_VERSIONS: 'state-versions',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type StateVersionDocument = {
    data?: StateVersion;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type StateVersionListingDocument = {
    data?: Array<StateVersion>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Status transition of entity.
 */
export type StatusTransition = {
    attributes: {
        'occurred-at': string;
        reason?: string | null;
        status: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        user?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
    };
    type: 'status-transitions';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type StatusTransitionDocument = {
    data?: StatusTransition;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Tag is a keyword or term associated with a Scalr resource.
 * It is used to label resources across the account to help to identify them, improve searchability
 * or can even participate in a terraform run e.g. as a part of metadata for policy decision.
 *
 * Tags are unique within the account. Deleted tags will be removed from associated resources.
 */
export type Tag = {
    attributes: {
        /**
         * The name of the tag. It must be unique within the account.
         */
        name: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account this tag belongs to.
         */
        readonly account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
    };
    type: 'tags';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TagDocument = {
    data?: Tag;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TagListingDocument = {
    data?: Array<Tag>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents tags' relationship.
 */
export type TagRelationship = {
    id: string;
    type: 'tags';
};

export type type21 = 'tags';

export const type21 = {
    TAGS: 'tags',
} as const;

/**
 * Document Listing.
 */
export type TagRelationshipFieldsetsListingDocument = {
    data?: Array<TagRelationship>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A [IAM](https://docs.scalr.io/docs/identity-and-access-management) team is used to organize users into logical units.
 *
 * A team can not be used to group service accounts, only standard users.
 */
export type Team = {
    attributes: {
        /**
         * The verbose description of the team.
         */
        description?: string | null;
        /**
         * The name of the team.
         */
        name: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account this team belongs to.
         */
        readonly account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * Identity provider of the team. Can be internal (Scalr) or external (LDAP/SAML)
         */
        readonly 'identity-provider'?: {
            data: {
                id: string;
                type: 'identity-providers';
            } | null;
        };
        /**
         * The list of users in the team.
         */
        users?: {
            data: Array<{
                id: string;
                type: 'users';
            }> | null;
        };
    };
    type: 'teams';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TeamDocument = {
    data?: Team;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TeamListingDocument = {
    data?: Array<Team>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform module usage instance.
 */
export type TerraformModuleUsage = {
    attributes: {
        module: string;
        'parent-module'?: string | null;
        source?: string | null;
        /**
         * Number of module versions.
         */
        'versions-used-count': number;
        /**
         * Number of module workspaces.
         */
        'workspaces-count': number;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The namespace this usage instance belongs to.
         */
        namespace?: {
            data: {
                id: string;
                type: 'tf-module-namespaces';
            } | null;
        };
    };
    type: 'tf-module-usages';
};

export type type22 = 'tf-module-namespaces';

export const type22 = {
    TF_MODULE_NAMESPACES: 'tf-module-namespaces',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformModuleUsageDocument = {
    data?: TerraformModuleUsage;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformModuleUsageListingDocument = {
    data?: Array<TerraformModuleUsage>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform module source
 */
export type TerraformModuleUsageSource = {
    source: string;
};

/**
 * Document Listing.
 */
export type TerraformModuleUsageSourceFieldsetsListingDocument = {
    data?: Array<TerraformModuleUsageSource>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform module version
 */
export type TerraformModuleUsageVersion = {
    version?: string;
};

/**
 * Document Listing.
 */
export type TerraformModuleUsageVersionFieldsetsListingDocument = {
    data?: Array<TerraformModuleUsageVersion>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform module version usage instance.
 */
export type TerraformModuleVersionUsage = {
    attributes: {
        'created-at': string;
        version?: string | null;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The environment this usage instance belongs to.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The workspace this usage instance belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'tf-module-version-usages';
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformModuleVersionUsageListingDocument = {
    data?: Array<TerraformModuleVersionUsage>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform provider usage instance.
 */
export type TerraformProviderUsage = {
    attributes: {
        provider: string;
        source: string;
        'versions-used-count': number;
        'workspaces-count': number;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    type: 'tf-provider-usages';
};

export type type23 = 'tf-provider-usages';

export const type23 = {
    TF_PROVIDER_USAGES: 'tf-provider-usages',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformProviderUsageDocument = {
    data?: TerraformProviderUsage;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformProviderUsageListingDocument = {
    data?: Array<TerraformProviderUsage>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform provider source
 */
export type TerraformProviderUsageSource = {
    source: string;
};

/**
 * Document Listing.
 */
export type TerraformProviderUsageSourceFieldsetsListingDocument = {
    data?: Array<TerraformProviderUsageSource>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform provider version
 */
export type TerraformProviderUsageVersion = {
    version: string;
};

/**
 * Document Listing.
 */
export type TerraformProviderUsageVersionFieldsetsListingDocument = {
    data?: Array<TerraformProviderUsageVersion>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform provider version usage.
 */
export type TerraformProviderVersionUsage = {
    attributes: {
        'created-at': string;
        version: string | null;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The environment this usage instance belongs to.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The workspace this usage belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'tf-provider-version-usages';
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformProviderVersionUsageListingDocument = {
    data?: Array<TerraformProviderVersionUsage>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform resource instance usage
 */
export type TerraformResourceInstanceUsage = {
    attributes: {
        /**
         * Resource instance address. Combines module, name and index of the resource.
         */
        address: string;
        /**
         * External ID of the resource instance.
         */
        'external-id': string;
        /**
         * Indicates if the resource instance is active.
         */
        'is-active'?: boolean;
        /**
         * Indicates if the resource is a duplicate
         */
        'is-duplicate'?: boolean;
        /**
         * Resource instance name.
         */
        name: string;
        /**
         * Time when the resource instance was created or updated.
         */
        'updated-at': string;
        /**
         * The email of the user who create or update this resource instance.
         */
        'updated-by-email': string;
        /**
         * Name of the workspace this resource instance belongs to.
         */
        'workspace-name': string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The environment this resource instance belongs to.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The resource this instance belongs to.
         */
        resource?: {
            data: {
                id: string;
                type: 'tf-resource-usages';
            } | null;
        };
        /**
         * The run which created or updated this resource instance.
         */
        run?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        /**
         * The state version this resource instance belongs to.
         */
        'state-version'?: {
            data: {
                id: string;
                type: 'state-versions';
            } | null;
        };
        /**
         * The workspace this resource instance belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'tf-resource-instance-usages';
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformResourceInstanceUsageListingDocument = {
    data?: Array<TerraformResourceInstanceUsage>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform resource usage instance
 */
export type TerraformResourceUsage = {
    attributes: {
        /**
         * The total number of resource instances which are present in the infrastructure.
         */
        'active-instances-count': number;
        /**
         * The total number of resource instances which are deleted from the infrastructure.
         */
        'deleted-instances-count': number;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Terraform provider by which resource is managed.
         */
        'provider-type': string;
        /**
         * The total number of workspaces where this resource is used.
         */
        'workspaces-count': number;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The account this resource belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
    };
    type: 'tf-resource-usages';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformResourceUsageDocument = {
    data?: TerraformResourceUsage;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformResourceUsageListingDocument = {
    data?: Array<TerraformResourceUsage>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform resource provider type
 */
export type TerraformResourceUsageProviderType = {
    /**
     * Terraform provider type.
     */
    'provider-type': string;
};

/**
 * Document Listing.
 */
export type TerraformResourceUsageProviderTypeFieldsetsListingDocument = {
    data?: Array<TerraformResourceUsageProviderType>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform version usage instance.
 */
export type TerraformVersionUsage = {
    attributes: {
        'created-at': string;
        /**
         * The IaC platform of the usage instance.
         */
        'iac-platform'?: 'terraform' | 'opentofu';
        version: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The account this usage instance belongs to.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * The environment this usage instance belongs to.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The workspace this usage instance belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'tf-version-usages';
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type TerraformVersionUsageListingDocument = {
    data?: Array<TerraformVersionUsage>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents terraform version
 */
export type TerraformVersionUsageVersion = {
    version: string;
};

/**
 * Document Listing.
 */
export type TerraformVersionUsageVersionFieldsetsListingDocument = {
    data?: Array<TerraformVersionUsageVersion>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type UsageStatistic = {
    attributes?: {
        /**
         * The identifier of a resource by which the usage is broken down
         */
        'breakdown-id'?: string | null;
        /**
         * The name of a resource by which the usage is broken down
         */
        'breakdown-name'?: string | null;
        /**
         * The date when usage has been recorded
         */
        date?: string | null;
        /**
         * The count of runs finished within the date
         */
        'runs-count'?: number;
        /**
         * The duration of runs in seconds within the date
         */
        'runs-seconds'?: number;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * The account id usage is reported for
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
    };
    type: 'usage-statistics';
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type UsageStatisticListingDocument = {
    data?: Array<UsageStatistic>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a Scalr [IAM](https://docs.scalr.io/docs/identity-and-access-management) user.
 */
export type User = {
    attributes: {
        'created-at'?: string | null;
        email: string;
        'full-name'?: string | null;
        'last-login-at'?: string | null;
        status?: 'Active' | 'Inactive' | 'Pending';
        username?: string;
    };
    readonly id?: string;
    readonly links?: {
        self?: string;
    };
    relationships?: {
        'identity-providers'?: {
            data: Array<{
                id: string;
                type: 'identity-providers';
            }> | null;
        };
        teams?: {
            data: Array<{
                id: string;
                type: 'teams';
            }> | null;
        };
    };
    type: 'users';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type UserDocument = {
    data?: User;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents an create [IAM](https://docs.scalr.io/docs/identity-and-access-management) account user request.
 */
export type UserInvite = {
    attributes: {
        email: string;
        /**
         * If set to `true`, email with invite to the account will be sent to the user email.
         */
        'send-invite'?: boolean;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships?: {
        /**
         * Assign roles for this user on the account scope.
         */
        roles?: {
            data: Array<{
                id: string;
                type: 'roles';
            }> | null;
        };
        /**
         * Add user to the teams.
         */
        teams?: {
            data: Array<{
                id: string;
                type: 'teams';
            }> | null;
        };
    };
    type: 'users';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type UserInviteDocument = {
    data?: UserInvite;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type UserListingDocument = {
    data?: Array<User>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A Variable describes the configuration and value of a variable in a workspace.
 *
 * In Scalr there are "terraform" and "environment" variables.
 *
 * * Terraform variables define values to be passed into the corresponding Terraform input variable
 * that is defined in the Configuration Version to be used in a run. Scalr Terraform variables
 * are added to the `terraform.tfvars.json` file in the working directory of the workspace prior to any run.
 * The values passed in can be HCL structures if the `hcl` attribute is `true`.
 * * Environment variables define shell variables that are added to the run time environment of a workspace
 * using `export VAR=value`. These variables can pass authentication parameters to providers
 * or any data required for local processing, such as via `local-exec` provisioners.
 */
export type Variable = {
    attributes: {
        /**
         * * `terraform` - Values to be passed to terraform input variables of the same name.
         * * `env` - shell environment variables. They will be injected via `export` during a terraform run.
         */
        category: 'terraform' | 'env' | 'shell';
        /**
         * Variable description.
         */
        description?: string | null;
        /**
         * Indicates whether the variable can be overridden on a lower down the Scalr organizational model.
         */
        final?: boolean;
        /**
         * Indicates whether the value of the variable is a string of HCL code.
         * Not applicable to `env` category variables.
         */
        hcl?: boolean;
        /**
         * Variable name. Must correspond to the name of a Terraform input variable in the configuration
         * if category is terraform.
         */
        key: string;
        /**
         * Indicates whether the value is sensitive. When set to `true` then the variable is not visible
         * after being written.
         */
        sensitive?: boolean;
        /**
         * The variable last update timestamp.
         */
        readonly 'updated-at'?: string | null;
        /**
         * The email of the last user who updated this variable.
         */
        readonly 'updated-by-email'?: string | null;
        /**
         * Variable value. Not visible if sensitive: true is enabled
         */
        value?: string | null;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account this variable belongs to
         */
        readonly account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * The environment this variable belongs to
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The user who updated this variable last time.
         */
        readonly 'updated-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * The workspace this variable belongs to.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'vars';
};

/**
 * * `terraform` - Values to be passed to terraform input variables of the same name.
 * * `env` - shell environment variables. They will be injected via `export` during a terraform run.
 */
export type category = 'terraform' | 'env' | 'shell';

/**
 * * `terraform` - Values to be passed to terraform input variables of the same name.
 * * `env` - shell environment variables. They will be injected via `export` during a terraform run.
 */
export const category = {
    TERRAFORM: 'terraform',
    ENV: 'env',
    SHELL: 'shell',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type VariableDocument = {
    data?: Variable;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type VariableListingDocument = {
    data?: Array<Variable>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * The [VCS Provider](../../vcs_providers.html) resource represents a connection between a Scalr
 * account and a VCS, such as GitHub, Gitlab, Bitbucket, and Azure DevOps.
 */
export type VcsProvider = {
    attributes: {
        /**
         * Authentication type, the VCS API client is using to establish connection with the VCS.
         *
         * * `oauth2` - private OAuth App, user or organization creates in their VCS account.
         * Setup through this method requires a user to complete a
         * [web flow through a browser](../../vcs_providers.html#github),
         * where the user should authorize Scalr to connect to their OAuth App.
         *
         * * `personal_token` - a pre-generated authentication token. This method works better if
         * you need to fully automate the VCS provider creation.
         *
         * How to generate access tokens for different VCS providers:
         * * [GitHub and GitHub Enterprise](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token)
         * * [GitLab and GitLab Enterprise](https://docs.gitlab.com/ce/user/profile/personal_access_tokens.html#creating-a-personal-access-token)
         * * [Azure DevOps](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops-2019&tabs=preview-page)
         * * [Bitbucket Data Center](https://confluence.atlassian.com/bitbucketserver/personal-access-tokens-939515499.html)
         */
        'auth-type': 'oauth2' | 'personal_token';
        /**
         * Indicates whether commenting on PRs is enabled for this VCS provider.
         */
        'comments-enabled'?: boolean;
        /**
         * Indicates whether the draft pull-request runs are enabled for this VCS provider.
         */
        'draft-pr-runs-enabled'?: boolean;
        /**
         * Contains error message, if the connection to VCS provider is broken.
         */
        readonly 'error-message'?: string | null;
        /**
         * Indicates whether the VCS provider can be used in any account environments or only linked one.
         */
        'is-shared'?: boolean;
        /**
         * VCS provider name, which must be unique within the account.
         */
        name: string;
        /**
         * Indicates whether triggering dry runs from a PR comment is enabled for this VCS provider.
         */
        'plans-enabled'?: boolean;
        /**
         * Access token for an API client for using to connect to the VCS Provider.
         */
        token?: string | null;
        /**
         * The URL to the VCS provider installation.
         * Required for GitHub Enterprise, GitLab Enterprise and Bitbucket Data Center.
         */
        url?: string | null;
        /**
         * Username for personal_token auth type. This field is required for bitbucket_enterprise provider.
         */
        username?: string | null;
        /**
         * VCS provider type.
         */
        'vcs-type':
            | 'github'
            | 'gitlab'
            | 'bitbucket'
            | 'bitbucket_enterprise'
            | 'gitlab_enterprise'
            | 'github_enterprise'
            | 'azure_dev_ops_services';
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships?: {
        /**
         * The account that owns this VCS integration.
         */
        account?: {
            data: {
                id: string;
                type: 'accounts';
            } | null;
        };
        /**
         * The ID of the agent pool to communicate with on-prem VCS provider that not accessible directly.
         */
        'agent-pool'?: {
            data: {
                id: string;
                type: 'agent-pools';
            } | null;
        };
        /**
         * The list of environments this VCS integration is linked to.
         */
        environments?: {
            data: Array<{
                id: string;
                type: 'environments';
            }> | null;
        };
    };
    type: 'vcs-providers';
};

/**
 * Authentication type, the VCS API client is using to establish connection with the VCS.
 *
 * * `oauth2` - private OAuth App, user or organization creates in their VCS account.
 * Setup through this method requires a user to complete a
 * [web flow through a browser](../../vcs_providers.html#github),
 * where the user should authorize Scalr to connect to their OAuth App.
 *
 * * `personal_token` - a pre-generated authentication token. This method works better if
 * you need to fully automate the VCS provider creation.
 *
 * How to generate access tokens for different VCS providers:
 * * [GitHub and GitHub Enterprise](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token)
 * * [GitLab and GitLab Enterprise](https://docs.gitlab.com/ce/user/profile/personal_access_tokens.html#creating-a-personal-access-token)
 * * [Azure DevOps](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops-2019&tabs=preview-page)
 * * [Bitbucket Data Center](https://confluence.atlassian.com/bitbucketserver/personal-access-tokens-939515499.html)
 */
export type auth_type = 'oauth2' | 'personal_token';

/**
 * Authentication type, the VCS API client is using to establish connection with the VCS.
 *
 * * `oauth2` - private OAuth App, user or organization creates in their VCS account.
 * Setup through this method requires a user to complete a
 * [web flow through a browser](../../vcs_providers.html#github),
 * where the user should authorize Scalr to connect to their OAuth App.
 *
 * * `personal_token` - a pre-generated authentication token. This method works better if
 * you need to fully automate the VCS provider creation.
 *
 * How to generate access tokens for different VCS providers:
 * * [GitHub and GitHub Enterprise](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token)
 * * [GitLab and GitLab Enterprise](https://docs.gitlab.com/ce/user/profile/personal_access_tokens.html#creating-a-personal-access-token)
 * * [Azure DevOps](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops-2019&tabs=preview-page)
 * * [Bitbucket Data Center](https://confluence.atlassian.com/bitbucketserver/personal-access-tokens-939515499.html)
 */
export const auth_type = {
    OAUTH2: 'oauth2',
    PERSONAL_TOKEN: 'personal_token',
} as const;

/**
 * VCS provider type.
 */
export type vcs_type =
    | 'github'
    | 'gitlab'
    | 'bitbucket'
    | 'bitbucket_enterprise'
    | 'gitlab_enterprise'
    | 'github_enterprise'
    | 'azure_dev_ops_services';

/**
 * VCS provider type.
 */
export const vcs_type = {
    GITHUB: 'github',
    GITLAB: 'gitlab',
    BITBUCKET: 'bitbucket',
    BITBUCKET_ENTERPRISE: 'bitbucket_enterprise',
    GITLAB_ENTERPRISE: 'gitlab_enterprise',
    GITHUB_ENTERPRISE: 'github_enterprise',
    AZURE_DEV_OPS_SERVICES: 'azure_dev_ops_services',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type VcsProviderDocument = {
    data?: VcsProvider;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type VcsProviderListingDocument = {
    data?: Array<VcsProvider>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Resource represents a VCS revision attributes.
 */
export type VcsRevision = {
    attributes?: {
        branch?: string | null;
        'clone-url'?: string;
        'commit-message'?: string | null;
        'commit-sha'?: string | null;
        'commit-url'?: string | null;
        'repository-id'?: string;
        'sender-username'?: string | null;
    };
    readonly id?: string;
    readonly links?: {
        self?: string;
    };
    type: 'vcs-revisions';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type VcsRevisionDocument = {
    data?: VcsRevision;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a request for creating a VCS task.
 */
export type VcsTaskRequest = {
    branch: string;
    'commit-sha': string;
    'repository-id': string;
};

/**
 * Represents the webhook integration
 *
 * The extra fields below are not available in response by default. Ask for them explicitly in the query parameter `fields[webhook-integrations]`:
 * * statistics
 */
export type WebhookIntegration = {
    attributes: {
        /**
         * Webhook can be turned off by setting to `false`.
         */
        enabled?: boolean;
        headers?: Array<{
            /**
             * A header name.
             */
            name: string;
            /**
             * Whether the value is a sensitive.
             */
            sensitive?: boolean;
            /**
             * A header value. Not visible if sensitive.
             */
            value: string | null;
        }> | null;
        readonly 'http-method'?: string;
        /**
         * Indicates whether the webhook is available in any environment of the account without directly linking it.
         */
        'is-shared'?: boolean;
        /**
         * The Date/Time of the last notification.
         */
        readonly 'last-triggered-at'?: string | null;
        /**
         * The number of retry attempts.
         */
        'max-attempts'?: number;
        /**
         * The name of the webhook. Use your target application/component name for better discoverability.
         */
        name: string;
        /**
         * The secret passphrase for HMAC signature.
         */
        'secret-key'?: string;
        /**
         * Webhook delivery statistics (delivered, failed and total) by periods: last hour, last day and last week
         */
        readonly statistics?: {
            'last-day'?: {
                delivered?: number;
                failed?: number;
                total?: number;
            };
            'last-hour'?: {
                delivered?: number;
                failed?: number;
                total?: number;
            };
            'last-week'?: {
                delivered?: number;
                failed?: number;
                total?: number;
            };
        } | null;
        /**
         * The HTTP transaction timeout.
         */
        timeout?: number;
        /**
         * HTTP(s) destination URL.
         */
        url: string;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The account this webhook belongs to.
         */
        account: {
            data: {
                id: string;
                type: 'accounts';
            };
        };
        /**
         * The list of environments this webhook is linked to.
         */
        environments?: {
            data: Array<{
                id: string;
                type: 'environments';
            }> | null;
        };
        /**
         * The list of events this webhook will be notified about.
         * Use [List Event Definitions](event-definitions.html#list-event-definitions) to obtain the list
         * of all available events.
         */
        events?: {
            data: Array<{
                id: string;
                type: 'event-definitions';
            }> | null;
        };
    };
    type: 'webhook-integrations';
};

/**
 * Represents an IaCP Webhook integration delivery.
 */
export type WebhookIntegrationDelivery = {
    attributes: {
        /**
         * The number of attempts made to deliver the webhook.
         */
        attempts?: number;
        /**
         * The error message, if any, encountered during delivery.
         */
        'error-message'?: string | null;
        /**
         * The Date/Time of the last attempt to deliver the webhook.
         */
        'last-handle-attempt-at'?: string;
        /**
         * The data payload (JSON format) sent in the webhook request body.
         */
        'request-body'?: {
            [key: string]: unknown;
        };
        /**
         * The HTTP request headers sent with the webhook.
         */
        'request-headers'?: {
            [key: string]: unknown;
        };
        /**
         * The data (JSON or plain text) received in the response body from the external system.
         */
        'response-body'?:
            | (
                  | {
                        [key: string]: unknown;
                    }
                  | string
              )
            | null;
        /**
         * The HTTP status code returned by the external system.
         */
        'response-code'?: number | null;
        /**
         * The HTTP response headers received from the external system.
         */
        'response-headers'?: {
            [key: string]: unknown;
        } | null;
        /**
         * The delivery status. Can be: `pending`, `completed`, or `failed`.
         */
        status: string;
        /**
         * The Date/Time when the webhook was triggered.
         */
        'triggered-at'?: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    relationships: {
        /**
         * The environment related to the webhook delivery.
         */
        environment?: {
            data: {
                id: string;
                type: 'environments';
            } | null;
        };
        /**
         * The specific event that triggered this webhook delivery.
         */
        event: {
            data: {
                id: string;
                type: 'event-definitions';
            };
        };
        /**
         * The optional run associated with the webhook delivery.
         */
        run?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        /**
         * The user who triggered the webhook.
         */
        'triggered-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * The webhook this delivery belongs to.
         */
        webhook: {
            data: {
                id: string;
                type: 'webhook-integrations';
            };
        };
        /**
         * The workspace related to the webhook delivery.
         */
        workspace?: {
            data: {
                id: string;
                type: 'workspaces';
            } | null;
        };
    };
    type: 'webhook-integration-deliveries';
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type WebhookIntegrationDeliveryDocument = {
    data?: WebhookIntegrationDelivery;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type WebhookIntegrationDeliveryListingDocument = {
    data?: Array<WebhookIntegrationDelivery>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type WebhookIntegrationDocument = {
    data?: WebhookIntegration;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type WebhookIntegrationListingDocument = {
    data?: Array<WebhookIntegration>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A Workspace is where Terraform runs are performed for a specific configuration, and where the resulting
 * state file(s) are stored.
 *
 * Workspaces belong to environments and can have `variables` configured to provide inputs to the configuration,
 * authenticate providers etc.
 *
 * The extra fields below are not available in response by default. Ask for them explicitly in the query parameter `fields[workspaces]`:
 * * module
 */
export type Workspace = {
    attributes: {
        /**
         * Cron expression for scheduled runs. Time should be in UTC.
         */
        readonly 'apply-schedule'?: string | null;
        /**
         * Indicates whether `terraform apply` should automatically run
         * when terraform plan ends without error. Default `false`.
         */
        'auto-apply'?: boolean;
        /**
         * How many days should the workspace exist.
         */
        'auto-destroy-days'?: (1 | 2 | 7 | 14) | null;
        /**
         * The status of scheduled destruction of the workspace.
         */
        readonly 'auto-destroy-status'?: string | null;
        /**
         * When should the destruction of the workspace begin.
         */
        readonly 'auto-destroy-time'?: string | null;
        /**
         * Indicates if runs have to be queued automatically when a new configuration version is uploaded.
         * `skip_first` - after the very first configuration version is uploaded into the workspace the run will not be triggered.
         * But the following configurations will do. This is the default behavior.
         * `always` - runs will be triggered automatically on every upload of the configuration version.
         * `never` - configuration versions are uploaded into the workspace, but runs will not be triggered.
         */
        'auto-queue-runs'?: 'always' | 'never' | 'skip_first';
        /**
         * The resource creation timestamp.
         */
        readonly 'created-at'?: string;
        /**
         * The email of a user who toggled deletion protection.
         */
        readonly 'deletion-protection-changed-by-email'?: string | null;
        /**
         * Designates whether deletion protection is enabled.
         */
        'deletion-protection-enabled'?: boolean;
        /**
         * Cron expression for scheduled destroy runs. Time should be in UTC.
         */
        readonly 'destroy-schedule'?: string | null;
        /**
         * The type of the Scalr Workspace environment.
         */
        'environment-type'?: 'production' | 'staging' | 'testing' | 'development' | 'unmapped';
        /**
         * Which execution mode to use. Valid values are `remote` and `local`.
         * When set to `local`, the workspace will be used for state storage only.
         */
        'execution-mode'?: 'remote' | 'local';
        /**
         * Indicates whether `force run` should automatically apply to latest run.
         * Default `false`.
         */
        'force-latest-run'?: boolean;
        /**
         * Indicates whether the workspace's current state version contains terraform resources.
         */
        readonly 'has-resources'?: boolean;
        hooks?: {
            /**
             * Command that should be run after terraform apply operation executed.
             */
            'post-apply'?: string | null;
            /**
             * Command that should be run after terraform plan operation executed.
             */
            'post-plan'?: string | null;
            /**
             * Command that should be run before terraform apply operation executed.
             */
            'pre-apply'?: string | null;
            /**
             * Command that should be run before terraform init operation executed.
             */
            'pre-init'?: string | null;
            /**
             * Command that should be run before terraform plan operation executed.
             */
            'pre-plan'?: string | null;
        } | null;
        /**
         * The IaC platform of this workspace.
         */
        'iac-platform'?: 'terraform' | 'opentofu';
        /**
         * The reason (if any) that the workspace has been locked.
         */
        readonly 'lock-reason'?: string | null;
        /**
         * Indicates whether the workspace is locked for operations. The `lock-reason` attribute
         * carries the explanation.
         *
         * This semaphore is acquired and released by terraform apply and can also manage it with
         * Lock/Unlock Workspace.
         *
         * Default: `false`
         */
        readonly locked?: boolean;
        /**
         * Workspace name which must be unique within the environment.
         *
         * Comprises letters, numbers, `-`, and `_` only.
         */
        name: string;
        /**
         * The attribute `operations` is deprecated. Use `execution-mode` instead.
         * @deprecated
         */
        operations?: boolean;
        readonly permissions?: {
            [key: string]: unknown;
        };
        /**
         * Specifies if the state is shared within the environment.
         */
        'remote-state-sharing'?: boolean;
        /**
         * The timeout for the Terraform Run operations (in minutes).
         */
        'run-operation-timeout'?: number | null;
        /**
         * The version of Terraform the workspace performs runs on. If omitted, the system default version is assigned.
         */
        'terraform-version'?: string;
        /**
         * The resource last update timestamp.
         */
        readonly 'updated-at'?: string | null;
        /**
         * The email of the last user, that updated this workspace.
         */
        readonly 'updated-by-email'?: string | null;
        /**
         * The list of Terraform variables files.
         */
        'var-files'?: Array<string> | null;
        'vcs-repo'?: {
            /**
             * Branch of a repository the workspace is associated with.
             * If omitted, the repository default branch will be used.
             */
            branch?: string | null;
            /**
             * When true once a pull request into the vcs-repo.branch is opened, every push
             * to a pull request's branch will trigger a dry run in the workspace. Default `true`
             */
            'dry-runs-enabled'?: boolean;
            /**
             * A reference to your VCS repository.
             *
             * For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`.
             * Azure DevOps Services has the format `<org>/<project>/<repo>`.
             */
            identifier: string;
            /**
             * Specifies whether git submodules should be fetched when cloning the VCS repository.
             */
            'ingress-submodules'?: boolean;
            /**
             * The attribute `vcs-repo.path` is deprecated. Use working-directory and trigger-prefixes instead.
             * @deprecated
             */
            path?: string | null;
            /**
             * List of path patterns in gitignore format, whose changes will trigger a run for the
             * workspace using this binding when the CV is created.
             * Conflicts with 'trigger-prefixes'.
             * If 'trigger-patterns' and 'trigger-prefixes' are omitted, any change in the configuration version root will trigger a new run.
             */
            'trigger-patterns'?: string | null;
            /**
             * List of paths (relative to the configuration version root), whose changes will trigger a run for the
             * workspace using this binding when the CV is created.
             * Conflicts with 'trigger-patterns'.
             * If 'trigger-patterns' and 'trigger-prefixes' are omitted, any change in the configuration version root will trigger a new run.
             */
            'trigger-prefixes'?: Array<string> | null;
        } | null;
        /**
         * A relative path where Terraform commands will execute in.
         */
        'working-directory'?: string | null;
    };
    readonly id?: string;
    readonly links?: {
        readonly self?: string;
    };
    relationships: {
        /**
         * The ID of the agent pool.
         */
        'agent-pool'?: {
            data: {
                id: string;
                type: 'agent-pools';
            } | null;
        };
        /**
         * The latest uploaded configuration version.
         */
        readonly 'configuration-version'?: {
            data: {
                id: string;
                type: 'configuration-versions';
            } | null;
        };
        /**
         * The user, who has triggered the run.
         */
        readonly 'created-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * Currently executing Run.
         */
        readonly 'current-run'?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        /**
         * The environment this workspace belongs to.
         */
        environment: {
            data: {
                id: string;
                type: 'environments';
            };
        };
        /**
         * The configuration version of the latest non-dry Run in this workspace.
         */
        readonly 'latest-configuration-version'?: {
            data: {
                id: string;
                type: 'configuration-versions';
            } | null;
        };
        /**
         * Latest finished Run.
         */
        readonly 'latest-run'?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        readonly 'locked-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        readonly 'locked-by-run'?: {
            data: {
                id: string;
                type: 'runs';
            } | null;
        };
        /**
         * The ID of the module.
         */
        readonly module?: {
            data: {
                id: string;
                type: 'modules';
            } | null;
        };
        /**
         * The ID of the module version.
         */
        'module-version'?: {
            data: {
                id: string;
                type: 'module-versions';
            } | null;
        };
        /**
         * The readme for the workspace.
         */
        readonly 'readme-id'?: {
            data: {
                id: string;
                type: 'workspace-readme';
            } | null;
        };
        tags?: {
            data: Array<{
                id: string;
                type: 'tags';
            }> | null;
        };
        /**
         * The last user, that updated this workspace.
         */
        readonly 'updated-by'?: {
            data: {
                id: string;
                type: 'users';
            } | null;
        };
        /**
         * VCS provider of the Run's workspace
         */
        'vcs-provider'?: {
            data: {
                id: string;
                type: 'vcs-providers';
            } | null;
        };
    };
    type: 'workspaces';
};

/**
 * How many days should the workspace exist.
 */
export type auto_destroy_days = 1 | 2 | 7 | 14;

/**
 * How many days should the workspace exist.
 */
export const auto_destroy_days = {
    _1: 1,
    _2: 2,
    _7: 7,
    _14: 14,
} as const;

/**
 * Indicates if runs have to be queued automatically when a new configuration version is uploaded.
 * `skip_first` - after the very first configuration version is uploaded into the workspace the run will not be triggered.
 * But the following configurations will do. This is the default behavior.
 * `always` - runs will be triggered automatically on every upload of the configuration version.
 * `never` - configuration versions are uploaded into the workspace, but runs will not be triggered.
 */
export type auto_queue_runs = 'always' | 'never' | 'skip_first';

/**
 * Indicates if runs have to be queued automatically when a new configuration version is uploaded.
 * `skip_first` - after the very first configuration version is uploaded into the workspace the run will not be triggered.
 * But the following configurations will do. This is the default behavior.
 * `always` - runs will be triggered automatically on every upload of the configuration version.
 * `never` - configuration versions are uploaded into the workspace, but runs will not be triggered.
 */
export const auto_queue_runs = {
    ALWAYS: 'always',
    NEVER: 'never',
    SKIP_FIRST: 'skip_first',
} as const;

/**
 * The type of the Scalr Workspace environment.
 */
export type environment_type = 'production' | 'staging' | 'testing' | 'development' | 'unmapped';

/**
 * The type of the Scalr Workspace environment.
 */
export const environment_type = {
    PRODUCTION: 'production',
    STAGING: 'staging',
    TESTING: 'testing',
    DEVELOPMENT: 'development',
    UNMAPPED: 'unmapped',
} as const;

/**
 * Which execution mode to use. Valid values are `remote` and `local`.
 * When set to `local`, the workspace will be used for state storage only.
 */
export type execution_mode = 'remote' | 'local';

/**
 * Which execution mode to use. Valid values are `remote` and `local`.
 * When set to `local`, the workspace will be used for state storage only.
 */
export const execution_mode = {
    REMOTE: 'remote',
    LOCAL: 'local',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type WorkspaceDocument = {
    data?: Workspace;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * JSON:API Document Listing
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type WorkspaceListingDocument = {
    data?: Array<Workspace>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * Represents a run output.
 */
export type WorkspaceOutput = {
    /**
     * The name of the output.
     */
    name?: string;
    /**
     * Whether the value of the output is sensitive.
     */
    sensitive?: boolean;
    /**
     * The value of the output.
     */
    value?: unknown;
};

/**
 * Document Listing.
 */
export type WorkspaceOutputFieldsetsListingDocument = {
    data?: Array<WorkspaceOutput>;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly links?: {
        [key: string]: string;
    };
    readonly meta?: {
        [key: string]: unknown;
    };
};

/**
 * A WorkspaceReadme resource represents the readme file for a workspace.
 */
export type WorkspaceReadme = {
    attributes?: {
        /**
         * The content of the readme file.
         */
        content?: string;
        /**
         * The time when the readme record was created.
         */
        'created-at'?: string;
    };
    readonly id?: string;
    links?: {
        [key: string]: string;
    };
    type: 'workspace-readme';
};

export type type24 = 'workspace-readme';

export const type24 = {
    WORKSPACE_README: 'workspace-readme',
} as const;

/**
 * JSON:API Document.
 *
 * see: https://jsonapi.org/format/#document-structure
 */
export type WorkspaceReadmeDocument = {
    data?: WorkspaceReadme;
    readonly included?: Array<{
        [key: string]: unknown;
    }>;
    readonly meta?: {
        [key: string]: unknown;
    };
};

export type WorkspaceSchedule = {
    'apply-schedule'?: string | null;
    'destroy-schedule'?: string | null;
};

export type GetAccountsData = {
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Account resource.
             */
            accounts?: string;
            /**
             * The comma-separated list of fields to return in response for BillingPlan resource.
             */
            'billing-plans'?: string;
            /**
             * The comma-separated list of fields to return in response for IdentityProvider resource.
             */
            'identity-providers'?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
        };
        /**
         * The account name filter.
         */
        'filter[name]'?: string;
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<'billing-plan' | 'identity-provider' | 'owner'>;
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
    };
};

export type GetAccountsResponse = AccountListingDocument;

export type GetAccountsError = unknown;

export type GetAccountData = {
    path: {
        /**
         * The ID of the account.
         */
        account: string;
    };
    query?: {
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<'billing-plan' | 'identity-provider' | 'owner'>;
    };
};

export type GetAccountResponse = AccountDocument;

export type GetAccountError = unknown;

export type UpdateAccountData = {
    body?: AccountDocument;
    path: {
        /**
         * The ID of the account to update.
         */
        account: string;
    };
};

export type UpdateAccountResponse = AccountDocument;

export type UpdateAccountError = unknown;

export type InviteUserToAccountData = {
    body?: UserInviteDocument;
    path: {
        account: string;
    };
    query?: {
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<'account' | 'teams' | 'user'>;
    };
};

export type InviteUserToAccountResponse = AccountUserDocument;

export type InviteUserToAccountError = unknown;

export type RemoveUserFromAccountData = {
    path: {
        /**
         * The ID of the account.
         */
        account: string;
        /**
         * The ID of the user.
         *
         */
        user: string;
    };
};

export type RemoveUserFromAccountResponse = void;

export type RemoveUserFromAccountError = unknown;

export type DeleteAccountBlobSettingsData = {
    path: {
        /**
         * The ID of the account.
         */
        account: string;
    };
};

export type DeleteAccountBlobSettingsResponse = void;

export type DeleteAccountBlobSettingsError = unknown;

export type GetAccountBlobSettingsData = {
    path: {
        /**
         * The ID of the account.
         */
        account: string;
    };
};

export type GetAccountBlobSettingsResponse = AccountBlobSettingsDocument;

export type GetAccountBlobSettingsError = unknown;

export type UpdateAccountBlobSettingsData = {
    body?: AccountBlobSettingsDocument;
    path: {
        /**
         * The ID of the account.
         */
        account: string;
    };
};

export type UpdateAccountBlobSettingsResponse = AccountBlobSettingsDocument;

export type UpdateAccountBlobSettingsError = unknown;

export type ReplaceAccountBlobSettingsData = {
    body?: AccountBlobSettingsDocument;
    path: {
        /**
         * The ID of the account.
         */
        account: string;
    };
};

export type ReplaceAccountBlobSettingsResponse = AccountBlobSettingsDocument;

export type ReplaceAccountBlobSettingsError = unknown;

export type GetMetricsData = {
    path: {
        /**
         * The ID of the account
         *
         */
        account: string;
    };
};

export type GetMetricsResponse = AccountMetrics;

export type GetMetricsError = unknown;

export type GetApplyData = {
    path: {
        /**
         * The ID of the apply.
         */
        apply: string;
    };
};

export type GetApplyResponse = ApplyDocument;

export type GetApplyError = unknown;

export type GetApplyLogData = {
    path: {
        /**
         * The ID of the apply. Obtain it from the
         * [Get a Workspace](workspaces.html#get-a-workspace) endpoint.
         */
        apply: string;
    };
    query?: {
        /**
         * Strip ANSI escape codes.
         */
        clean?: boolean;
    };
};

export type GetApplyLogResponse = unknown | void;

export type GetApplyLogError = unknown;

export type ListEnvironmentsData = {
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Account resource.
             */
            accounts?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for PolicyGroup resource.
             */
            'policy-groups'?: string;
            /**
             * The comma-separated list of fields to return in response for ProviderConfiguration resource.
             */
            'provider-configurations'?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
        };
        /**
         * The ID of the Account
         */
        'filter[account]'?: string;
        /**
         * The ID of the Environment
         */
        'filter[environment]'?: string;
        /**
         * Filter by latest run date. Example: `filter[latest-run-date]=between:2022-01-01T00:00:00Z,2022-02-01T00:00:00Z`
         */
        'filter[latest-run-date]'?: string;
        /**
         * The environment name filter.
         */
        'filter[name]'?: string;
        /**
         * The ID of the Policy Group.
         */
        'filter[policy-group]'?: string;
        /**
         * Filter environments by tags
         */
        'filter[tag]'?: string;
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<
            | 'account'
            | 'created-by'
            | 'default-provider-configurations'
            | 'policy-groups'
            | 'provider-configurations'
            | 'tags'
        >;
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
        /**
         * Query string, search by id, name.
         */
        query?: string;
        /**
         * The comma-separated list of attributes.
         */
        sort?: Array<'account' | 'cost-estimation-enabled' | 'created-at' | 'created-by-email' | 'name'>;
    };
};

export type ListEnvironmentsResponse = EnvironmentListingDocument;

export type ListEnvironmentsError = unknown;

export type CreateEnvironmentData = {
    body?: EnvironmentDocument;
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Account resource.
             */
            accounts?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for PolicyGroup resource.
             */
            'policy-groups'?: string;
            /**
             * The comma-separated list of fields to return in response for ProviderConfiguration resource.
             */
            'provider-configurations'?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
        };
    };
};

export type CreateEnvironmentResponse = EnvironmentDocument;

export type CreateEnvironmentError = unknown;

export type DeleteEnvironmentData = {
    path: {
        /**
         * The ID of the environment to delete.
         */
        environment: string;
    };
};

export type DeleteEnvironmentResponse = void;

export type DeleteEnvironmentError = unknown;

export type GetEnvironmentData = {
    path: {
        /**
         * The ID of the environment.
         */
        environment: string;
    };
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Account resource.
             */
            accounts?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for PolicyGroup resource.
             */
            'policy-groups'?: string;
            /**
             * The comma-separated list of fields to return in response for ProviderConfiguration resource.
             */
            'provider-configurations'?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
        };
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<
            | 'account'
            | 'created-by'
            | 'default-provider-configurations'
            | 'policy-groups'
            | 'provider-configurations'
            | 'tags'
        >;
    };
};

export type GetEnvironmentResponse = EnvironmentDocument;

export type GetEnvironmentError = unknown;

export type UpdateEnvironmentData = {
    body?: EnvironmentDocument;
    path: {
        /**
         * The ID of the environment to update.
         */
        environment: string;
    };
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Account resource.
             */
            accounts?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for PolicyGroup resource.
             */
            'policy-groups'?: string;
            /**
             * The comma-separated list of fields to return in response for ProviderConfiguration resource.
             */
            'provider-configurations'?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
        };
    };
};

export type UpdateEnvironmentResponse = EnvironmentDocument;

export type UpdateEnvironmentError = unknown;

export type DeleteEnvironmentTagsData = {
    body?: TagRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The environment whose tags will be deleted.
         *
         */
        environment: string;
    };
};

export type DeleteEnvironmentTagsResponse = void;

export type DeleteEnvironmentTagsError = unknown;

export type ListEnvironmentTagsData = {
    path: {
        /**
         * The environment to list tags for.
         *
         */
        environment: string;
    };
    query?: {
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
    };
};

export type ListEnvironmentTagsResponse = TagRelationshipFieldsetsListingDocument;

export type ListEnvironmentTagsError = unknown;

export type ReplaceEnvironmentTagsData = {
    body?: TagRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The environment whose tags will be replaced.
         *
         */
        environment: string;
    };
};

export type ReplaceEnvironmentTagsResponse = void;

export type ReplaceEnvironmentTagsError = unknown;

export type AddEnvironmentTagsData = {
    body?: TagRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The environment to add the tags to.
         *
         */
        environment: string;
    };
};

export type AddEnvironmentTagsResponse = void;

export type AddEnvironmentTagsError = unknown;

export type GetPlanData = {
    path: {
        /**
         * The ID of the plan.
         */
        plan: string;
    };
};

export type GetPlanResponse = PlanDocument;

export type GetPlanError = unknown;

export type GetJsonOutputData = {
    path: {
        /**
         * The ID of the plan. Obtain it from the
         * [Get a Workspace](workspaces.html#get-a-workspace) endpoint.
         */
        plan: string;
    };
    query?: {
        /**
         * Format of the response.
         */
        format?: 'text' | 'gzip';
    };
};

export type GetJsonOutputResponse = unknown | void;

export type GetJsonOutputError = unknown;

export type GetPlanLogData = {
    path: {
        /**
         * The ID of the plan. Obtain it from the
         * [Get a Workspace](workspaces.html#get-a-workspace) endpoint.
         */
        plan: string;
    };
    query?: {
        /**
         * Strip ANSI escape codes.
         */
        clean?: boolean;
    };
};

export type GetPlanLogResponse = unknown | void;

export type GetPlanLogError = unknown;

export type GetSanitizedJsonOutputData = {
    path: {
        /**
         * The ID of the plan. Obtain it from the
         * [Get a Workspace](workspaces.html#get-a-workspace) endpoint.
         */
        plan: string;
    };
    query?: {
        /**
         * Format of the response.
         */
        format?: 'text' | 'gzip';
    };
};

export type GetSanitizedJsonOutputResponse = unknown | void;

export type GetSanitizedJsonOutputError = unknown;

export type GetRunsData = {
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Apply resource.
             */
            applies?: string;
            /**
             * The comma-separated list of fields to return in response for ConfigurationVersion resource.
             */
            'configuration-versions'?: string;
            /**
             * The comma-separated list of fields to return in response for CostEstimate resource.
             */
            'cost-estimates'?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for Plan resource.
             */
            plans?: string;
            /**
             * The comma-separated list of fields to return in response for PolicyCheck resource.
             */
            'policy-checks'?: string;
            /**
             * The comma-separated list of fields to return in response for Run resource.
             */
            runs?: string;
            /**
             * The comma-separated list of fields to return in response for StatusTransition resource.
             */
            'status-transitions'?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
            /**
             * The comma-separated list of fields to return in response for VcsRevision resource.
             */
            'vcs-revisions'?: string;
            /**
             * The comma-separated list of fields to return in response for Workspace resource.
             */
            workspaces?: string;
        };
        /**
         * The account ID to list runs for.
         */
        'filter[account]'?: string;
        /**
         * The run created at filter.
         */
        'filter[created-at]'?: string;
        /**
         * The ID of the Run which triggered this run
         */
        'filter[created-by-run]'?: string;
        /**
         * The ID of the User who triggered this run
         */
        'filter[created-by]'?: string;
        /**
         * The environment ID to list runs for.
         */
        'filter[environment]'?: string;
        /**
         * The is dry runs filter.
         */
        'filter[is-dry]'?: string;
        /**
         * Filter the runs by drifted resources count.
         */
        'filter[resource-drifts]'?: string;
        /**
         * The comma-separated list of run IDs.
         */
        'filter[run]'?: string;
        /**
         * The run source filter.
         */
        'filter[source]'?: string;
        /**
         * The run status filter.
         */
        'filter[status]'?: string;
        /**
         * Filter runs by tags.
         */
        'filter[tag]'?: string;
        /**
         * Commit sha that affected runs
         */
        'filter[vcs-revision]'?: string;
        /**
         * The workspace ID to list runs for.
         */
        'filter[workspace]'?: string;
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<
            | 'apply'
            | 'configuration-version'
            | 'cost-estimate'
            | 'created-by'
            | 'created-by-run'
            | 'environment'
            | 'plan'
            | 'policy-checks'
            | 'status-transitions'
            | 'tags'
            | 'vcs-revision'
            | 'workspace'
        >;
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
        /**
         * Query string
         */
        query?: string;
        /**
         * List only runs that are scheduled.
         */
        scheduled?: string;
    };
};

export type GetRunsResponse = RunListingDocument;

export type GetRunsError = unknown;

export type CreateRunData = {
    body?: RunDocument;
};

export type CreateRunResponse = RunDocument;

export type CreateRunError = unknown;

export type GetRunsQueueData = {
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Apply resource.
             */
            applies?: string;
            /**
             * The comma-separated list of fields to return in response for ConfigurationVersion resource.
             */
            'configuration-versions'?: string;
            /**
             * The comma-separated list of fields to return in response for CostEstimate resource.
             */
            'cost-estimates'?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for Plan resource.
             */
            plans?: string;
            /**
             * The comma-separated list of fields to return in response for PolicyCheck resource.
             */
            'policy-checks'?: string;
            /**
             * The comma-separated list of fields to return in response for Run resource.
             */
            runs?: string;
            /**
             * The comma-separated list of fields to return in response for StatusTransition resource.
             */
            'status-transitions'?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
            /**
             * The comma-separated list of fields to return in response for VcsRevision resource.
             */
            'vcs-revisions'?: string;
            /**
             * The comma-separated list of fields to return in response for Workspace resource.
             */
            workspaces?: string;
        };
        /**
         * The account ID to list runs for.
         */
        'filter[account]'?: string;
        /**
         * The run created at filter.
         */
        'filter[created-at]'?: string;
        /**
         * The ID of the Run which triggered this run
         */
        'filter[created-by-run]'?: string;
        /**
         * The ID of the User who triggered this run
         */
        'filter[created-by]'?: string;
        /**
         * The environment ID to list runs for.
         */
        'filter[environment]'?: string;
        /**
         * The is dry runs filter.
         */
        'filter[is-dry]'?: string;
        /**
         * Filter the runs by drifted resources count.
         */
        'filter[resource-drifts]'?: string;
        /**
         * The comma-separated list of run IDs.
         */
        'filter[run]'?: string;
        /**
         * The run source filter.
         */
        'filter[source]'?: string;
        /**
         * The run status filter.
         */
        'filter[status]'?: string;
        /**
         * Filter runs by tags.
         */
        'filter[tag]'?: string;
        /**
         * Commit sha that affected runs
         */
        'filter[vcs-revision]'?: string;
        /**
         * The workspace ID to list runs for.
         */
        'filter[workspace]'?: string;
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<
            | 'apply'
            | 'configuration-version'
            | 'cost-estimate'
            | 'created-by'
            | 'created-by-run'
            | 'environment'
            | 'plan'
            | 'policy-checks'
            | 'status-transitions'
            | 'tags'
            | 'vcs-revision'
            | 'workspace'
        >;
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
        /**
         * Query string
         */
        query?: string;
        /**
         * List only runs that are scheduled.
         */
        scheduled?: string;
    };
};

export type GetRunsQueueResponse = RunListingDocument;

export type GetRunsQueueError = unknown;

export type GetRunData = {
    path: {
        /**
         * The ID of the run to show.
         */
        run: string;
    };
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for Apply resource.
             */
            applies?: string;
            /**
             * The comma-separated list of fields to return in response for ConfigurationVersion resource.
             */
            'configuration-versions'?: string;
            /**
             * The comma-separated list of fields to return in response for CostEstimate resource.
             */
            'cost-estimates'?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for Plan resource.
             */
            plans?: string;
            /**
             * The comma-separated list of fields to return in response for PolicyCheck resource.
             */
            'policy-checks'?: string;
            /**
             * The comma-separated list of fields to return in response for Run resource.
             */
            runs?: string;
            /**
             * The comma-separated list of fields to return in response for StatusTransition resource.
             */
            'status-transitions'?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
            /**
             * The comma-separated list of fields to return in response for VcsRevision resource.
             */
            'vcs-revisions'?: string;
            /**
             * The comma-separated list of fields to return in response for Workspace resource.
             */
            workspaces?: string;
        };
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<
            | 'apply'
            | 'configuration-version'
            | 'cost-estimate'
            | 'created-by'
            | 'created-by-run'
            | 'environment'
            | 'plan'
            | 'policy-checks'
            | 'status-transitions'
            | 'tags'
            | 'vcs-revision'
            | 'workspace'
        >;
    };
};

export type GetRunResponse = RunDocument;

export type GetRunError = unknown;

export type ConfirmRunData = {
    body?: ConfirmRequest;
    path: {
        /**
         * The ID of the run to confirm.
         */
        run: string;
    };
};

export type ConfirmRunResponse = unknown;

export type ConfirmRunError = unknown;

export type CancelRunData = {
    body?: Comment;
    path: {
        /**
         * The ID of the run to cancel.
         */
        run: string;
    };
};

export type CancelRunResponse = unknown | void;

export type CancelRunError = unknown;

export type DiscardRunData = {
    body?: Comment;
    path: {
        /**
         * The ID of run to discard.
         */
        run: string;
    };
};

export type DiscardRunResponse = unknown;

export type DiscardRunError = unknown;

export type ForceRunData = {
    body?: Comment;
    path: {
        /**
         * The ID of the run to force.
         */
        run: string;
    };
};

export type ForceRunResponse = unknown;

export type ForceRunError = unknown;

export type ListPolicyChecksData = {
    path: {
        /**
         * The ID of the run.
         */
        run: string;
    };
};

export type ListPolicyChecksResponse = PolicyCheckListingDocument;

export type ListPolicyChecksError = unknown;

export type DownloadPolicyInputData = {
    path: {
        /**
         * The ID of the run.
         */
        run: string;
    };
};

export type DownloadPolicyInputResponse = unknown;

export type DownloadPolicyInputError = unknown;

export type GetWorkspacesData = {
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for AgentPool resource.
             */
            'agent-pools'?: string;
            /**
             * The comma-separated list of fields to return in response for ConfigurationVersion resource.
             */
            'configuration-versions'?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for ModuleVersion resource.
             */
            'module-versions'?: string;
            /**
             * The comma-separated list of fields to return in response for Module resource.
             */
            modules?: string;
            /**
             * The comma-separated list of fields to return in response for Run resource.
             */
            runs?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
            /**
             * The comma-separated list of fields to return in response for VcsProvider resource.
             */
            'vcs-providers'?: string;
            /**
             * The comma-separated list of fields to return in response for WorkspaceReadme resource.
             */
            'workspace-readme'?: string;
            /**
             * The comma-separated list of fields to return in response for Workspace resource.
             */
            workspaces?: string;
        };
        /**
         * The ID of the Account
         */
        'filter[account]'?: string;
        /**
         * The ID(s) of the Agent Pool.
         */
        'filter[agent-pool]'?: string;
        /**
         * The ID of the User who created this workspace
         */
        'filter[created-by]'?: string;
        /**
         * Deletion protection enabled filter
         */
        'filter[deletion-protection-enabled]'?: string;
        /**
         * Workspace environment type
         */
        'filter[environment-type]'?: string;
        /**
         * The ID of the Environment
         */
        'filter[environment]'?: string;
        /**
         * Has resources filter
         */
        'filter[has-resources]'?: string;
        /**
         * Workspace name
         */
        'filter[name]'?: string;
        /**
         * The ID of the Provider configuration.
         */
        'filter[provider-configuration]'?: string;
        /**
         * Last run created by filter
         */
        'filter[run][created-by]'?: string;
        /**
         * Filter the workspaces by last run drifted resources count.
         */
        'filter[run][resource-drifts]'?: string;
        /**
         * Last run status
         */
        'filter[run][status]'?: string;
        /**
         * The ID of the Software Version
         */
        'filter[software-version]'?: string;
        /**
         * Filter workspaces by tags
         */
        'filter[tag]'?: string;
        /**
         * Date of workspace modification.
         */
        'filter[updated-at]'?: string;
        /**
         * The ID of the User who update this workspace
         */
        'filter[updated-by]'?: string;
        /**
         * The ID of the VCS provider
         */
        'filter[vcs-provider]'?: string;
        /**
         * Filter by VCS repository
         */
        'filter[vcs-repo][identifier]'?: string;
        /**
         * The ID(s) of the Workspace.
         */
        'filter[workspace]'?: string;
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<
            | 'agent-pool'
            | 'configuration-version'
            | 'created-by'
            | 'environment'
            | 'latest-configuration-version'
            | 'latest-run'
            | 'locked-by'
            | 'locked-by-run'
            | 'module'
            | 'module-version'
            | 'readme-id'
            | 'tags'
            | 'updated-by'
            | 'vcs-provider'
        >;
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
        /**
         * Query string, search by id, name.
         */
        query?: string;
        /**
         * The comma-separated list of attributes.
         */
        sort?: Array<'environment' | 'latest-run' | 'name' | 'updated-at'>;
    };
};

export type GetWorkspacesResponse = WorkspaceListingDocument;

export type GetWorkspacesError = unknown;

export type CreateWorkspaceData = {
    body?: WorkspaceDocument;
};

export type CreateWorkspaceResponse = WorkspaceDocument;

export type CreateWorkspaceError = unknown;

export type DeleteWorkspaceData = {
    path: {
        /**
         * The ID of the workspace to be deleted.
         */
        workspace: string;
    };
};

export type DeleteWorkspaceResponse = void;

export type DeleteWorkspaceError = unknown;

export type GetWorkspaceData = {
    path: {
        /**
         * The workspace ID to show.
         */
        workspace: string;
    };
    query?: {
        /**
         * The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
         */
        fields?: {
            /**
             * The comma-separated list of fields to return in response for AgentPool resource.
             */
            'agent-pools'?: string;
            /**
             * The comma-separated list of fields to return in response for ConfigurationVersion resource.
             */
            'configuration-versions'?: string;
            /**
             * The comma-separated list of fields to return in response for Environment resource.
             */
            environments?: string;
            /**
             * The comma-separated list of fields to return in response for ModuleVersion resource.
             */
            'module-versions'?: string;
            /**
             * The comma-separated list of fields to return in response for Module resource.
             */
            modules?: string;
            /**
             * The comma-separated list of fields to return in response for Run resource.
             */
            runs?: string;
            /**
             * The comma-separated list of fields to return in response for Tag resource.
             */
            tags?: string;
            /**
             * The comma-separated list of fields to return in response for User resource.
             */
            users?: string;
            /**
             * The comma-separated list of fields to return in response for VcsProvider resource.
             */
            'vcs-providers'?: string;
            /**
             * The comma-separated list of fields to return in response for WorkspaceReadme resource.
             */
            'workspace-readme'?: string;
            /**
             * The comma-separated list of fields to return in response for Workspace resource.
             */
            workspaces?: string;
        };
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<
            | 'agent-pool'
            | 'configuration-version'
            | 'created-by'
            | 'environment'
            | 'latest-configuration-version'
            | 'latest-run'
            | 'locked-by'
            | 'locked-by-run'
            | 'module'
            | 'module-version'
            | 'readme-id'
            | 'tags'
            | 'updated-by'
            | 'vcs-provider'
        >;
    };
};

export type GetWorkspaceResponse = WorkspaceDocument;

export type GetWorkspaceError = unknown;

export type UpdateWorkspaceData = {
    body?: WorkspaceDocument;
    path: {
        /**
         * The ID of the workspace to be updated.
         */
        workspace: string;
    };
};

export type UpdateWorkspaceResponse = WorkspaceDocument;

export type UpdateWorkspaceError = unknown;

export type LockWorkspaceData = {
    body?: Reason;
    path: {
        /**
         * The workspace ID to lock.
         */
        workspace: string;
    };
};

export type LockWorkspaceResponse = WorkspaceDocument;

export type LockWorkspaceError = unknown;

export type ResyncWorkspaceData = {
    path: {
        /**
         * The ID of the workspace to resync.
         */
        workspace: string;
    };
};

export type ResyncWorkspaceResponse = ConfigurationVersionDocument;

export type ResyncWorkspaceError = unknown;

export type SetScheduleData = {
    body?: WorkspaceSchedule;
    path: {
        /**
         * The ID of the workspace to be updated.
         */
        workspace: string;
    };
};

export type SetScheduleResponse = WorkspaceDocument;

export type SetScheduleError = unknown;

export type UnlockWorkspaceData = {
    path: {
        /**
         * The workspace ID to unlock.
         */
        workspace: string;
    };
};

export type UnlockWorkspaceResponse = WorkspaceDocument;

export type UnlockWorkspaceError = unknown;

export type GetCurrentStateVersionData = {
    path: {
        /**
         * The ID of the workspace.
         */
        workspace: string;
    };
};

export type GetCurrentStateVersionResponse = StateVersionDocument;

export type GetCurrentStateVersionError = unknown;

export type GetWorkspaceOutputsData = {
    path: {
        /**
         * The workspace to list outputs for.
         *
         */
        workspace: string;
    };
};

export type GetWorkspaceOutputsResponse = WorkspaceOutputFieldsetsListingDocument;

export type GetWorkspaceOutputsError = unknown;

export type ListProviderConfigurationLinksData = {
    path: {
        /**
         * The ID of the Workspace.
         *
         */
        workspace: string;
    };
    query?: {
        /**
         * The comma-separated list of relationship paths.
         */
        include?: Array<'provider-configuration'>;
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
        /**
         * The comma-separated list of attributes.
         */
        sort?: Array<'name'>;
    };
};

export type ListProviderConfigurationLinksResponse = ProviderConfigurationLinkListingDocument;

export type ListProviderConfigurationLinksError = unknown;

export type CreateProviderConfigurationLinkData = {
    body?: ProviderConfigurationLinkDocument;
    path: {
        /**
         * The ID of the Workspace.
         *
         */
        workspace: string;
    };
};

export type CreateProviderConfigurationLinkResponse = ProviderConfigurationLinkDocument;

export type CreateProviderConfigurationLinkError = unknown;

export type DeleteRemoteStateConsumersData = {
    body?: RemoteStateConsumerRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The ID of the workspace.
         *
         */
        workspace: string;
    };
};

export type DeleteRemoteStateConsumersResponse = void;

export type DeleteRemoteStateConsumersError = unknown;

export type ListRemoteStateConsumersData = {
    path: {
        /**
         * The ID of the workspace.
         *
         */
        workspace: string;
    };
    query?: {
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
    };
};

export type ListRemoteStateConsumersResponse = RemoteStateConsumerRelationshipFieldsetsListingDocument;

export type ListRemoteStateConsumersError = unknown;

export type ReplaceRemoteStateConsumersData = {
    body?: RemoteStateConsumerRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The ID of the workspace.
         *
         */
        workspace: string;
    };
};

export type ReplaceRemoteStateConsumersResponse = void;

export type ReplaceRemoteStateConsumersError = unknown;

export type AddRemoteStateConsumersData = {
    body?: RemoteStateConsumerRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The ID of the workspace.
         *
         */
        workspace: string;
    };
};

export type AddRemoteStateConsumersResponse = void;

export type AddRemoteStateConsumersError = unknown;

export type DeleteWorkspaceTagsData = {
    body?: TagRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The workspace whose tags will be deleted.
         *
         */
        workspace: string;
    };
};

export type DeleteWorkspaceTagsResponse = void;

export type DeleteWorkspaceTagsError = unknown;

export type ListWorkspaceTagsData = {
    path: {
        /**
         * The workspace to list tags for.
         *
         */
        workspace: string;
    };
    query?: {
        /**
         * Page number
         */
        'page[number]'?: string;
        /**
         * Page size
         */
        'page[size]'?: string;
    };
};

export type ListWorkspaceTagsResponse = TagRelationshipFieldsetsListingDocument;

export type ListWorkspaceTagsError = unknown;

export type ReplaceWorkspaceTagsData = {
    body?: TagRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The workspace whose tags will be replaced.
         *
         */
        workspace: string;
    };
};

export type ReplaceWorkspaceTagsResponse = void;

export type ReplaceWorkspaceTagsError = unknown;

export type AddWorkspaceTagsData = {
    body?: TagRelationshipFieldsetsListingDocument;
    path: {
        /**
         * The workspace to add the tags to.
         *
         */
        workspace: string;
    };
};

export type AddWorkspaceTagsResponse = void;

export type AddWorkspaceTagsError = unknown;
